# we could work with the vectorized nature of == using the function all():
x <- 1:3
y <- c(1, 3, 4)
x == y
all(x == y)
identical(x,y)
# add names
x <- c(1, 2, 4)
names(x)
names(x) <- c("a", "b", "ab")
names(x)
x
# remove names
names(x) <- NULL
x
# reference elements of the vector by name:
x <- c(1, 2, 4)
names(x) <- c("a", "b", "ab")
x["b"]
# if the arguments you pass to c are of different modes, they will be reduced to a type that is the lowest common denominator
c(5, 2, "abc") # mixing integer and character modes, and R chooses the latter
c(5, 2, list(a = 1, b = 4)) # list mode here is of lower precedence
# c has a flattening effect for vectors:
c(5, 2, c(1.5, 6)) # this just results in a single vector, not a 2-level list
# list with tags
j <- list(name = "Joe", salary = 55000, union = T)
j
# list without tags
jalt <- list("Joe", 55000, T)
jalt
j$salary
j$salary
j[["salary"]]
j[[2]]
# double brackets
j$salary
j[["salary"]]
j[[2]]
# single brackets
j["salary"]
j[2]
j[1:2]
j2 <- j[2]
j2 # returns the result in the form of a list
class(j2)
j2a <- j[[2]]
j2a # works since we are only accessing a single element
class(j2a)
str(j2)
z <- list(a = "abc", b = 12)
z
# adding components
z$c <- "sailing"
z
# adding components via vector indexing
z[[4]] <- 28
z[5:7] <- c(FALSE, TRUE, TRUE)
z
# deleting elements
z$b <- NULL
z
# concatenating lists
c(list("Joe", 55000, T), list(5))
length(j)
# getting components tags
names(j)
# getting values
# character strings
ulj <- unlist(j)
class(ulj)
ulj
# numeric vector
z <- list(a = 5, b = 12, c = 13)
y <- unlist(z)
class(y)
y
# mixed = output -> the least common denominator: character strings
w <- list(a = 5, b = "xyz")
wu <- unlist(w)
class(wu)
wu
# removing names
names(wu) <- NULL
wu
# we can also remove the elements' names directly with unname:
wun <- unname(wu)
wun
lapply(list(1:3, 25:29), median)
sapply(list(1:3,25:29),median)
b <- list(u = 5, v = 12)
c <- list(w = 13)
a <- list(b, c)
a
length(a)
c(list(a = 1, b = 2, c = list(d = 5, e = 9)))
# flattening a list
c(list(a = 1, b = 2, c = list(d = 5, e = 9)), recursive = T)
kids <- c("Jack", "Jill")
ages <- c(12, 10)
d <- data.frame(kids, ages, stringsAsFactors = FALSE) # produce a data frame from our two vectors: kids and ages
d
# accessing data frames -> vector fashion
d[[1]]
d$kids
# matrix fashion
d[, 1]
str(d)
examsquiz <- read.table("input/ExamsQuiz.txt", header = TRUE)
examsquiz
# returns another data frame
examsquiz[2:5, ]
# returns a vector
examsquiz[2:5, 2]
class(examsquiz[2:5, 2])
# returns a one-column data frame
examsquiz[2:5, 2, drop = FALSE]
class(examsquiz[2:5, 2, drop = FALSE])
# filtering
examsquiz[examsquiz$MIDTERM >= 3.8, ]
x <- c(2, NA, 4)
mean(x)
mean(x, na.rm = TRUE)
# using subset() -> na.rm = TRUE per default
subset(examsquiz, MIDTERM >= 3.8)
# getting rid of any NA's observations
kids2 <- c("Jack", NA, "Jillian", "John")
states <- c("CA", "MA", "MA", NA)
d4 <- data.frame(kids2, states, stringsAsFactors = FALSE)
complete.cases(d4)
d5 <- d4[complete.cases(d4), ]
d5
kids3 <- c("Jack", "Jill")
ages <- c(12, 10)
d <- data.frame(kids3, ages, stringsAsFactors = FALSE)
d
# adding rows
d <- rbind(d, list("Laura", 19))
d
# creating new columns from old ones
eq <- cbind(examsquiz, examsquiz$FINAL - examsquiz$MIDTERM)
class(eq)
eq
# better solution
examsquiz$ExamDiff <- examsquiz$FINAL - examsquiz$MIDTERM
examsquiz
# adding cols with recycling
d$one <- 1
d
apply(examsquiz, 1, max)
kids.names <- c("Jack", "Jill", "Jillian", "John")
kids.states <- c("CA", "MA", "MA", "HI")
d1 <- data.frame(kids.names, kids.states, stringsAsFactors = FALSE)
kids.names <- c("Jill", "Lillian", "Jack")
kids.ages <- c(10, 7, 12)
d2 <- data.frame(kids.names, kids.ages, stringsAsFactors = FALSE)
d <- merge(d1, d2)
dl <- lapply(d2, sort)
dl
as.data.frame(dl)
x <- c(5, 12, 13, 12)
xf <- factor(x)
xf
str(xf)
unclass(xf)
length(xf)
# anticipating levels
xff <- factor(x, levels = c(5, 12, 13, 88))
xff
xff[2] <- 88
xff
ages <- c(25, 26, 55, 37, 21, 42)
affils <- c("R", "D", "D", "R", "U", "D")
tapply(ages, affils, mean)
# with two or more factors
d <- data.frame(list(gender = c("M", "M", "F", "M", "F", "F"), age = c(47, 59, 21, 32, 33, 24), income = c(55000, 88000, 32450, 76500, 123000, 45650)))
d
d$over25 <- ifelse(d$age > 25, 1, 0)
d
tapply(d$income, list(d$gender, d$over25), mean)
split(d$income, list(d$gender, d$over25))
# determine the indices of the vector elements corresponding to male, female, and infant
g <- c("M", "F", "F", "I", "M", "M", "F")
split(1:7, g)
by(data, data$sex, function(m) lm(m[, 2] ~ m[, 3]))
u <- c(22, 8, 33, 6, 8, 29, -2)
fl <- list(c(5, 12, 13, 12, 13, 5, 13), c("a", "bc", "a", "a", "bc", "a", "a"))
# creating a contingency table
tapply(u, fl, length)
# or (better!)
table(fl)
# getting one-dimensional count
table(c(5, 12, 13, 12, 8, 5))
# another contingency table example
ct <- read.table("input/ct.tsv", header = T)
ct
cttab <- table(ct)
cttab
class(cttab)
cttab[1, 1]
cttab[1, ]
# change cell counts to proportions
cttab / 5
# in pct
cttab / 5 * 100
# getting marginal totals
apply(cttab, 1, sum)
addmargins(cttab)
# getting names of the dimensions and levels
dimnames(cttab)
# extracting a subtable
subtable <- function(tbl, subnames) {
tblarray <- unclass(tbl)
dcargs <- list(tblarray)
ndims <- length(subnames)
for (i in 1:ndims) {
dcargs[[i + 1]] <- subnames[[i]]
}
subarray <- do.call("[", dcargs)
dims <- lapply(subnames, length)
subtbl <- array(subarray, dims, dimnames = subnames)
class(subtbl) <- "table"
return(subtbl)
}
subtable(cttab, list(Vote.for.X = c("No", "Yes"), Voted.for.X.Last.Time = c("No", "Yes")))
# focusing on the cells with the largest frequencies
# finds the cells in table tbl with the k highest frequencies; handling of ties is unrefined
tabdom <- function(tbl, k) {
tbldf <- as.data.frame(tbl)
freqord <- order(tbldf$Freq, decreasing = TRUE)
dom <- tbldf[freqord, ][1:k, ]
return(dom)
}
d <- c(5, 12, 13, 4, 3, 28, 12, 12, 9, 5, 5, 13, 5, 4, 12)
dtab <- table(d)
tabdom(dtab, 3)
tabdom(cttab, 2)
aggregate(data[, -1], list(data$sex), median)
z <- c(0.88114802, 0.28532689, 0.58647376, 0.42851862, 0.46881514, 0.24226859, 0.05289197, 0.88035617)
binmarks <- seq(from = 0.0, to = 1.0, by = 0.1)
cut(z, binmarks, labels = F) # This says that z[1], 0.88114802, fell into bin 9, which was (0,0,0.1]; z[2], 0.28532689, fell into bin 3; and so on.
# very simple loop
x <- c(5, 12, 13)
for (n in x) print(n^2)
# while and repeat
i <- 1
while(i <= 10) i <- i + 4;
i
# similar
i <- 1
while(TRUE){
i <- i + 4
if(i > 10) break
}
i
# similar
i <- 1
repeat{
i <- i + 4
if(i > 10) break
}
i
sim <- function(nreps) {
commdata <- list()
commdata$countabsamecomm <- 0
for (rep in 1:nreps) {
commdata$whosleft <- 1:20
commdata$numabchosen <- 0
commdata <- choosecomm(commdata, 5)
if (commdata$numabchosen > 0) next
commdata <- choosecomm(commdata, 4)
if (commdata$numabchosen > 0) next
commdata <- choosecomm(commdata, 3)
}
print(commdata$countabsamecomm / nreps)
}
# The two next statements occur within the loop that starts at line 1325. Thus, when the if condition holds in line 1329, lines 1330 through 1332 will be skipped, and control will transfer to line 1325. The situation in line 1331 is similar.
# without using next, we would need to resort to nested if statements
sim <- function(nreps) {
commdata <- list()
commdata$countabsamecomm <- 0
for (rep in 1:nreps) {
commdata$whosleft <- 1:20
commdata$numabchosen <- 0
commdata <- choosecomm(commdata, 5)
if (commdata$numabchosen == 0) {
commdata <- choosecomm(commdata, 4)
if (commdata$numabchosen == 0) {
commdata <- choosecomm(commdata, 3)
}
}
}
print(commdata$countabsamecomm / nreps)
}
# applying lm() to two matrices
u <- matrix(c(1, 2, 3, 1, 2, 4), nrow = 3, ncol = 2)
v <- matrix(c(8, 12, 20, 15, 10, 2), nrow = 3, ncol = 2)
for (m in c("u", "v")) {
z <- get(m)
print(lm(z[, 2] ~ z[, 1]))
}
x <- 2
y <- if (x == 2) x else x + 1
y
x <- 3
y <- if (x == 2) x else x + 1
y
# testscores <- read.table("exams", header = TRUE)
oddcount <- function(x) {
k <- 0 # assign 0 to k
for (n in x) {
if (n %% 2 == 1) k <- k + 1 # %% is the modulo operator
}
return(k)
}
# on the other hand (returning k as our last statement)
oddcount2 <- function(x) {
k <- 0 # assign 0 to k
for (n in x) {
if (n %% 2 == 1) k <- k + 1 # %% is the modulo operator
}
k
}
g <- function() {
t <- function(x) {
return(x^2)
}
return(t)
}
g()
g <- function(x) {
return(x + 1)
}
?"{"
# accessing arguments of a function
formals(g)
body(g)
# printing a function
g
page(abline)
# built-in function in C
sum
f1 <- function(a, b) {
return(a + b)
}
f2 <- function(a, b) {
return(a - b)
}
f <- f1
f(3, 2)
f <- f2
# looping through a list of functions
g1 <- function(x) {
return(sin(x))
}
g2 <- function(x) {
return(sqrt(x^2 + 1))
}
g3 <- function(x) {
return(2 * x - 1)
}
plot(c(0, 1), c(-1, 1.5)) # prepare the graph, specifying X and Y ranges
for (f in c(g1, g2, g3)) plot(f, 0, 1, add = T) # add plot to existing graph
w <- 12
f <- function(y) {
d <- 8
h <- function() {
return(d * (w + y))
}
return(h())
}
environment(f)
ls()
# ls.str()
f(2)
x <- c(13, 5, 12)
sort(x)
x
# reassigning the arguments
x <- sort(x)
x
# function with several variables of output
oddsevens <- function(v) {
odds <- which(v %% 2 == 1)
evens <- which(v %% 2 == 1)
list(o = odds, e = evens)
}
# lintr::lint("main.Rmd", linters =
#               lintr::with_defaults(
#                 commented_code_linter = NULL,
#                 trailing_whitespace_linter = NULL
#                 )
#             )
# if you have additional scripts and want them to be linted too, add them here
# lintr::lint("scripts/my_script.R")
g <- function() {
t <- function(x) {
return(x^2)
}
return(t)
}
g()
# accessing arguments of a function
formals(g)
g <- function(x) {
return(x + 1)
}
?"{"
# accessing arguments of a function
formals(g)
body(g)
# printing a function
g
# built-in function in C
sum
f1 <- function(a, b) {
return(a + b)
}
f2 <- function(a, b) {
return(a - b)
}
f <- f1
f(3, 2)
f <- f2
f <- f2
g1 <- function(x) {
return(sin(x))
}
g2 <- function(x) {
return(sqrt(x^2 + 1))
}
g3 <- function(x) {
return(2 * x - 1)
}
plot(c(0, 1), c(-1, 1.5)) # prepare the graph, specifying X and Y ranges
for (f in c(g1, g2, g3)) plot(f, 0, 1, add = T) # add plot to existing graph
w <- 12
f <- function(y) {
d <- 8
h <- function() {
return(d * (w + y))
}
return(h())
}
environment(f)
ls()
# ls.str()
w <- 12
f <- function(y) {
d <- 8
h <- function() {
return(d * (w + y))
}
return(h())
}
environment(f)
f(2)
x <- c(13, 5, 12)
sort(x)
x
x <- sort(x)
x
## By default, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(
echo=TRUE, message=FALSE, warning=FALSE
)
# CONFIG
user_name <- "fernandomillanvillalobos" # your Git username (only needed if
# you want to deploy to GH pages)
project_name <- "art-programming-r" # adapt!
package_date <- "2022-05-01" # date of the CRAN snapshot that
# the checkpoint package uses
r_version <- "4.2.0" # R-Version to use
options(Ncpus = 4) # use 4 cores for parallelized installation of packages
if (r_version != paste0(version$major, ".", version$minor)) {
stop("ERROR: specified R version does not match currently used.")
}
## By default, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(
echo=TRUE, message=FALSE, warning=FALSE
)
# CONFIG
user_name <- "fernandomillanvillalobos" # your Git username (only needed if
# you want to deploy to GH pages)
project_name <- "art-programming-r" # adapt!
package_date <- "2022-05-01" # date of the CRAN snapshot that
# the checkpoint package uses
r_version <- "4.2.0" # R-Version to use
options(Ncpus = 4) # use 4 cores for parallelized installation of packages
if (r_version != paste0(version$major, ".", version$minor)) {
stop("ERROR: specified R version does not match currently used.")
}
## By default, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(
echo=TRUE, message=FALSE, warning=FALSE
)
# CONFIG
user_name <- "fernandomillanvillalobos" # your Git username (only needed if
# you want to deploy to GH pages)
project_name <- "art-programming-r" # adapt!
package_date <- "2022-05-01" # date of the CRAN snapshot that
# the checkpoint package uses
r_version <- "4.2.0" # R-Version to use
options(Ncpus = 4) # use 4 cores for parallelized installation of packages
if (r_version != paste0(version$major, ".", version$minor)) {
stop("ERROR: specified R version does not match currently used.")
}
