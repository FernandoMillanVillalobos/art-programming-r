}
# nolint end
# install packages for the specified CRAN snapshot date
checkpoint(snapshot_date = package_date,
project = path_to_wd,
verbose = T,
scanForPackages = T,
use.knitr = F,
R.version = r_version)
rm(package_date)
source("manifest.R")
unlink("manifest.R")
sessionInfo()
# if you want to outsource logic to other script files, see README for
# further information
# Load all visualizations functions as separate scripts
knitr::read_chunk("scripts/dviz.supp.R")
source("scripts/dviz.supp.R")
knitr::read_chunk("scripts/themes.R")
source("scripts/themes.R")
knitr::read_chunk("scripts/plot_grid.R")
source("scripts/plot_grid.R")
knitr::read_chunk("scripts/align_legend.R")
source("scripts/align_legend.R")
knitr::read_chunk("scripts/label_log10.R")
source("scripts/label_log10.R")
knitr::read_chunk("scripts/outliers.R")
source("scripts/outliers.R")
# base-R
hist(Nile)
# Tidy
dn <- data.frame(Nile)
ggplot(dn) +
geom_histogram(aes(Nile), dn)
mean(Nile[80:100])
# Case study: tapply()
# tapply(what to split, how to split it, what to apply to the resulting chunks)
# 1) base-R
aggregate(airquality[, "Ozone"],
list(Month = airquality[, "Month"]),
mean,
na.rm = TRUE
)
# 2) base-R
aq <- na.omit(airquality)
tapply(aq$Ozone, aq$Month, mean)
# Tidy
group_by(airquality, Month) %>%
summarize(o3 = mean(Ozone, na.rm = TRUE))
# Case study: tapply (II)
data("mlb", package = "regtools")
htsAndWts <- tapply(mlb$Weight, mlb$Height, mean)
plot(htsAndWts)
# Tidy
mlb %>%
group_by(Height) %>%
summarize(weights = mean(Weight)) %>%
ggplot(aes(x = Height, y = weights)) +
geom_point()
# avoiding $ use
# Tidy
loans_tidy <- openintro::loans_full_schema %>%
mutate(
homeownership = str_to_title(homeownership),
bankruptcy = if_else(public_record_bankrupt >= 1, "Yes", "No")
) %>%
filter(annual_income >= 10)
loans_tidy
# base-R
loans_base <- openintro::loans_full_schema
loans_base$bankruptcy <- ifelse(loans_base$public_record_bankrupt >= 1, "Yes", "No")
subset(loans_base, annual_income >= 10)
loans_base
# avoiding [] use
# base-R
x <- c(5, 12, 13, 1)
x[x > 8]
# or, if preferred:
subset(x, x > 8)
# Tidy
data.frame(x = x) %>% filter(x > 8)
# base-R
mtcars$hwratio <- mtcars$hp / mtcars$wt
mtcars$hwratio
# Tidy
mtcars %>% mutate(hwratio = hp / wt) -> mtcars
# recoding variables
# base-R
mtcars$transmission <-
ifelse(mtcars$am == 0, "automatic", "manual")
# Tidy
mtcars <- mtcars %>%
mutate(
transmission =
case_when(
am == 0 ~ "automatic",
am == 1 ~ "manual"
)
)
# base-R
mtcars$gear_char <-
ifelse(mtcars$gear == 3,
"three",
ifelse(mtcars$gear == 4,
"four",
"five"
)
)
# Tidy
mtcars <- mtcars %>%
mutate(
gear_char =
case_when(
gear == 3 ~ "three",
gear == 4 ~ "four",
gear == 5 ~ "five"
)
)
# combining base-R and Tidy
mtcars$gear_char <-
case_when(
mtcars$gear == 3 ~ "three",
mtcars$gear == 4 ~ "four",
mtcars$gear == 5 ~ "five"
)
# Tidy v1
mtcars %>%
group_by(cyl, gear) %>%
summarize(mean(mpg))
# Tidy v2 (no 8 cylinder, 4 speed cars)
mtcars$cyl <- as.factor(mtcars$cyl)
mtcars$gear <- as.factor(mtcars$gear)
mtcars %>%
group_by(cyl, gear, .drop = FALSE) %>%
summarize(mean(mpg))
# base-R
tapply(mtcars$mpg, list(mtcars$cyl, mtcars$gear), mean)
# regressing miles per gallon against weight, calculating R2 for each cylinder group
# Tidy
mtcars %>%
split(.$cyl) %>%
map(~ lm(mpg ~ wt, data = .)) %>%
map(summary) %>%
map_dbl("r.squared")
# base-R
# 1) creating a function
lmr2 <- function(mtcSubset) {
lmout <- lm(mpg ~ wt, data = mtcSubset)
summary(lmout)$r.squared
}
# 2) dividing cyl variable
u <- split(mtcars, mtcars$cyl)
# applying the function
sapply(u, lmr2)
x <- c(88, 5, 12, 13)
x <- c(x[1:3], 168, x[4]) #insert 168 before the 13
x
x <- c(1,2,4)
length(x)
m <- rbind(c(1,2), c(3,4))
m
m + 10:13
y <- vector(length = 2)
y[1] <- 5
y[2] <- 12 # does work
y
y <- c(5, 12) # also works
y
c(1, 2, 4) + c(6, 0, 9, 20, 22)
# gives the same result as:
c(1, 2, 4, 1, 2) + c(6, 0, 9, 20, 22)
#a more subtle example:
x <- cbind(c(1, 2, 3), c(4, 5, 6))
x
x + c(1, 2) # remember, matrices are actually long vectors! We are essentially doing this -> x + c(1,2,1,2,1,2)
y <- c(1.2, 3.9, 0.4, 0.12)
y[c(1, 3)] # extract elements 1 and 3 of y
y[2:3] # elements 2 and 3
v <- 3:4
y[v] # elements 3 and 4
x <- c(4, 2, 17, 5)
y <- x[c(1, 1, 3)] # duplicates are allowed
y
# Negative subscripts are used to exclude given elements:
z <- c(5, 12, 13)
z[-1] # exclude element 1
z[-1:-2] # exclude elements 1 through 2
# pick up all elements of a vector except for the last
z <- c(5, 12, 13)
z[1:length(z) - 1]
# equivalently:
z[-length(z)]
5:8
5:1
# Beware of operator precedence issues:
i <- 2
1:i - 1 # this means (1:i) - 1
# In the expression 1:i-1, the colon operator takes precedence over the subtraction. So, the expression 1:i is evaluated first, returning 1:2. R then subtracts 1 from that expression. That means subtracting a one-element vector from a two-element one, which is done via recycling. The one-element vector (1) will be extended to (1,1) to be of compatible length with 1:2. Element-wise subtraction then yields the vector (0,1).
1:(i - 1)
seq(from = 12, to = 30, by = 3)
seq(1.1, 2, length = 10)
# Dealing with empty-vectors
x <- c(5,12,13)
x
seq(x) # vector is NOT empty
x <- NULL
seq(x) # empty vector
x <- rep(8, 4)
x
rep(c(5, 12, 13), 3)
rep(1:3, 2)
# also a named argument, "each" which interleaves the copies of x
rep(c(5, 12, 13), each = 2)
x <- 1:10
any(x > 8)
any(x > 88)
all(x > 8)
all(x > 0)
# Extended Example: Finding Runs of Consecutive Ones
# start with a function to do this:
findruns <- function(x, k) {
n <- length(x)
runs <- NULL
for (i in 1:(n - k + 1)) {
if (all(x[i:(i + k - 1)] == 1)) {
runs <- c(runs, i)
}
return(runs)
}
}
#let's test it:
y <- c(1, 0, 0, 1, 1, 1, 0, 1, 1)
findruns(y, 3)
findruns(y, 2)
findruns(y, 6)
#although the code is correct, it may be slow since each call to runs<-c(runs,i) allocates a new vector
#an alternative is to preallocate the memory space like this:
findruns1 <- function(x, k) {
n <- length(x)
runs <- vector(length = n)
count <- 0
for (i in 1:(n - k + 1)) {
if (all(x[i:(i + k - 1)] == 1)) {
count <- count + 1
runs[count] <- i
}
}
if (count > 0) {
runs <- runs[1:count]
} else {
runs <- NULL
}
return(runs)
}
findruns1(y, 3)
findruns1(y, 2)
findruns1(y, 6)
# Extended Example: Predicting Discrete-Valued Time Series
# a naive approach:
preda <- function(x, k) {
n <- length(x)
k2 <- k / 2
# the vector pred will contain our predicted values
pred <- vector(length = n - k)
for (i in 1:(n - k)) {
if (sum(x[i:(i + (k - 1))]) >= k2) pred[i] <- 1 else pred[i] <- 0
}
return(mean(abs(pred - x[(k + 1):n])))
}
predb <- function(x, k) {
n <- length(x)
k2 <- k / 2
pred <- vector(length = n - k)
sm <- sum(x[1:k])
if (sm >= k2) pred[1] <- 1 else pred[1] <- 0
if (n - k >= 2) {
for (i in 2:(n - k)) {
sm <- sm + x[i + k - 1] - x[i - 1]
if (sm >= k2) pred[i] <- 1 else pred[i] <- 0
}
}
return(mean(abs(pred - x[(k + 1):n])))
}
predc <- function(x, k) {
n <- length(x)
k2 <- k / 2
pred <- vector(length = n - k)
csx <- c(o, cumsum(x))
for (i in 1:(n - k)) {
if (csx[i + k] - csx[i] >= k2) pred[i] <- 1 else pred[i] <- 0
}
return(mean(abs(pred - x[(k + 1):n])))
}
# some examples of vectorized functions
u <- c(5, 2, 8)
v <- c(1, 3, 9)
u > v
# example of an R function using vectorized operations
w <- function(x) {
return(x + 1)
}
w(u) # Here, w() uses +, which is vectorized, so w() is vectorized as well.
# built-in R vectorized functions
sqrt(1:9)
y <- c(1.2, 3.9, 0.4)
z <- round(y)
z
# even operators like + are really functions:
y <- c(12, 5, 13)
y + 4
"+"(y, 4) ## note too that recycling occurs here! 4 becomes (4,4,4).
# now let's consider vectorized functions that appear to have scalar arguments
f <- function(x, c) { # c is intended to be a scalar here
return((x + c)^2)
}
f(1:3, 0)
f(1:3, 1)
# a vector-valued function
z12 <- function(z) {
return(c(z, z^2))
}
x <- 1:8
z12(x) # returns vector and values over these vectors together
# would be natural to represent these numbers as a matrix
matrix(z12(x), ncol = 2)
#the call sapply(x,f) applies the function f() to each element of x and then converts the result to a matrix
z12 <- function(z) {
return(c(z, z^2))
}
sapply(1:8, z12)
# Using NA
x <- c(88, NA, 12, 168, 13)
x
mean(x)
mean(x, na.rm = TRUE)
# we have to specify if we want R to ignore the NA, but it will automatically ignore a NULL
x <- c(88, NULL, 12, 168, 13)
mean(x)
# there are multiple NA values, one for each mode:
x <- c(5, NA, 12)
mode(x[1])
mode(x[2])
y <- c("abc", "def", NA)
mode(y[2])
mode(y[3])
# Using NULL
# One use of NULL is to build up vectors in loops, in which each iteration adds another element to the vector
z <- NULL
for (i in 1:10) if (i %% 2 == 0) z <- c(z, i)
z
# in opposite to NAs
z <- NA
for (i in 1:10) if (i %% 2 == 0) z <- c(z, i)
z
z <- c(5, 2, -3, 8)
z
z * z > 8 # we see that the operator >, like +, is actually a function
# for example:
">"(2, 1)
">"(2, 5)
# so the
z * z > 8
# is really equivalent to
">"(z * z, 8)
# in other words, we are applying a function to vectors, and thus the result is a vector (of Booleans)
# we define our extraction condition in terms of z, but then use the results to extract from another vector y
z <- c(5, 2, -3, 8)
j <- z * z > 8
j
y <- c(1, 2, 30, 5)
y[j]
# or, more compactly:
z <- c(5, 2, -3, 8)
y <- c(1, 2, 30, 5)
y[z * z > 8]
# another example: we have a vector x in which we wish to replace all elements larger than a 3 with a 0
x[x > 3] <- 0
x
# Let's check:
x <- c(1, 3, 8, 2, 20)
x[x > 3] <- 0
x
x <- c(6, 1:3, NA, 12)
x
x[x > 5] # NA included
subset(x, x > 5) # NA not included
z <- c(5, 2, -3, 8)
which(z * z > 8) # returns the elements of z which have squares greater than 8 (1,3,and 4)
x <- 1:10
y <- ifelse(x %% 2 == 0, 5, 12)
y # we are producing a vector in which there is a 5 wherever x is even or a 12 wherever x is odd
# another example:
x <- c(5, 2, 9, 12)
ifelse(x > 6, 2 * x, 3 * x)
# read data
data <- read.csv("http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data", header = FALSE)
names(data) <- c(
"sex", "length", "diameter", "height", "weight.whole",
"weight.shucked", "weight.viscera", "weight.shell", "rings"
)
data2 <- ifelse(data == "M", 1, ifelse(data == "F", 2, 3))
pchvec <- ifelse(data$gender == "M", "o", "x")
plot(data$length, data$diameter, pch = pchvec)
# If we want to test whether two vectors are equal, the naive approach using == won't work:
x <- 1:3
y <- c(1, 3, 4)
x == y
# we could work with the vectorized nature of == using the function all():
x <- 1:3
y <- c(1, 3, 4)
x == y
all(x == y)
identical(x,y)
# add names
x <- c(1, 2, 4)
names(x)
names(x) <- c("a", "b", "ab")
names(x)
x
# remove names
names(x) <- NULL
x
# reference elements of the vector by name:
x <- c(1, 2, 4)
names(x) <- c("a", "b", "ab")
x["b"]
# if the arguments you pass to c are of different modes, they will be reduced to a type that is the lowest common denominator
c(5, 2, "abc") # mixing integer and character modes, and R chooses the latter
c(5, 2, list(a = 1, b = 4)) # list mode here is of lower precedence
# c has a flattening effect for vectors:
c(5, 2, c(1.5, 6)) # this just results in a single vector, not a 2-level list
# list with tags
j <- list(name = "Joe", salary = 55000, union = T)
j
# list without tags
jalt <- list("Joe", 55000, T)
jalt
j$salary
j$salary
j[["salary"]]
j[[2]]
# double brackets
j$salary
j[["salary"]]
j[[2]]
# single brackets
j["salary"]
j[2]
j[1:2]
j2 <- j[2]
j2 # returns the result in the form of a list
class(j2)
j2a <- j[[2]]
j2a # works since we are only accessing a single element
class(j2a)
str(j2)
z <- list(a = "abc", b = 12)
z
# adding components
z$c <- "sailing"
z
# adding components via vector indexing
z[[4]] <- 28
z[5:7] <- c(FALSE, TRUE, TRUE)
z
# deleting elements
z$b <- NULL
z
# concatenating lists
c(list("Joe", 55000, T), list(5))
length(j)
# getting components tags
names(j)
# getting values
# character strings
ulj <- unlist(j)
class(ulj)
ulj
# numeric vector
z <- list(a = 5, b = 12, c = 13)
y <- unlist(z)
class(y)
y
# mixed = output -> the least common denominator: character strings
w <- list(a = 5, b = "xyz")
wu <- unlist(w)
class(wu)
wu
# removing names
names(wu) <- NULL
wu
# we can also remove the elements' names directly with unname:
wun <- unname(wu)
wun
lapply(list(1:3, 25:29), median)
sapply(list(1:3,25:29),median)
b <- list(u = 5, v = 12)
c <- list(w = 13)
a <- list(b, c)
a
length(a)
c(list(a = 1, b = 2, c = list(d = 5, e = 9)))
# flattening a list
c(list(a = 1, b = 2, c = list(d = 5, e = 9)), recursive = T)
# lintr::lint("main.Rmd", linters =
#               lintr::with_defaults(
#                 commented_code_linter = NULL,
#                 trailing_whitespace_linter = NULL
#                 )
#             )
# if you have additional scripts and want them to be linted too, add them here
# lintr::lint("scripts/my_script.R")
