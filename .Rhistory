}
return(runs)
}
}
#let's test it:
y <- c(1, 0, 0, 1, 1, 1, 0, 1, 1)
findruns(y, 3)
findruns(y, 2)
findruns(y, 6)
#although the code is correct, it may be slow since each call to runs<-c(runs,i) allocates a new vector
#an alternative is to preallocate the memory space like this:
findruns1 <- function(x, k) {
n <- length(x)
runs <- vector(length = n)
count <- 0
for (i in 1:(n - k + 1)) {
if (all(x[i:(i + k - 1)] == 1)) {
count <- count + 1
runs[count] <- i
}
}
if (count > 0) {
runs <- runs[1:count]
} else {
runs <- NULL
}
return(runs)
}
findruns1(y, 3)
findruns1(y, 2)
findruns1(y, 6)
# Extended Example: Predicting Discrete-Valued Time Series
# a naive approach:
preda <- function(x, k) {
n <- length(x)
k2 <- k / 2
# the vector pred will contain our predicted values
pred <- vector(length = n - k)
for (i in 1:(n - k)) {
if (sum(x[i:(i + (k - 1))]) >= k2) pred[i] <- 1 else pred[i] <- 0
}
return(mean(abs(pred - x[(k + 1):n])))
}
predb <- function(x, k) {
n <- length(x)
k2 <- k / 2
pred <- vector(length = n - k)
sm <- sum(x[1:k])
if (sm >= k2) pred[1] <- 1 else pred[1] <- 0
if (n - k >= 2) {
for (i in 2:(n - k)) {
sm <- sm + x[i + k - 1] - x[i - 1]
if (sm >= k2) pred[i] <- 1 else pred[i] <- 0
}
}
return(mean(abs(pred - x[(k + 1):n])))
}
predc <- function(x, k) {
n <- length(x)
k2 <- k / 2
pred <- vector(length = n - k)
csx <- c(o, cumsum(x))
for (i in 1:(n - k)) {
if (csx[i + k] - csx[i] >= k2) pred[i] <- 1 else pred[i] <- 0
}
return(mean(abs(pred - x[(k + 1):n])))
}
# some examples of vectorized functions
u <- c(5, 2, 8)
v <- c(1, 3, 9)
u > v
# example of an R function using vectorized operations
w <- function(x) {
return(x + 1)
}
w(u) # Here, w() uses +, which is vectorized, so w() is vectorized as well.
# built-in R vectorized functions
sqrt(1:9)
y <- c(1.2, 3.9, 0.4)
z <- round(y)
z
# even operators like + are really functions:
y <- c(12, 5, 13)
y + 4
"+"(y, 4) ## note too that recycling occurs here! 4 becomes (4,4,4).
# now let's consider vectorized functions that appear to have scalar arguments
f <- function(x, c) { # c is intended to be a scalar here
return((x + c)^2)
}
f(1:3, 0)
f(1:3, 1)
# a vector-valued function
z12 <- function(z) {
return(c(z, z^2))
}
x <- 1:8
z12(x) # returns vector and values over these vectors together
# would be natural to represent these numbers as a matrix
matrix(z12(x), ncol = 2)
#the call sapply(x,f) applies the function f() to each element of x and then converts the result to a matrix
z12 <- function(z) {
return(c(z, z^2))
}
sapply(1:8, z12)
# Using NA
x <- c(88, NA, 12, 168, 13)
x
mean(x)
mean(x, na.rm = TRUE)
# we have to specify if we want R to ignore the NA, but it will automatically ignore a NULL
x <- c(88, NULL, 12, 168, 13)
mean(x)
# there are multiple NA values, one for each mode:
x <- c(5, NA, 12)
mode(x[1])
mode(x[2])
y <- c("abc", "def", NA)
mode(y[2])
mode(y[3])
# Using NULL
# One use of NULL is to build up vectors in loops, in which each iteration adds another element to the vector
z <- NULL
for (i in 1:10) if (i %% 2 == 0) z <- c(z, i)
z
# in opposite to NAs
z <- NA
for (i in 1:10) if (i %% 2 == 0) z <- c(z, i)
z
z <- c(5, 2, -3, 8)
z
z * z > 8 # we see that the operator >, like +, is actually a function
# for example:
">"(2, 1)
">"(2, 5)
# so the
z * z > 8
# is really equivalent to
">"(z * z, 8)
# in other words, we are applying a function to vectors, and thus the result is a vector (of Booleans)
# we define our extraction condition in terms of z, but then use the results to extract from another vector y
z <- c(5, 2, -3, 8)
j <- z * z > 8
j
y <- c(1, 2, 30, 5)
y[j]
# or, more compactly:
z <- c(5, 2, -3, 8)
y <- c(1, 2, 30, 5)
y[z * z > 8]
# another example: we have a vector x in which we wish to replace all elements larger than a 3 with a 0
x[x > 3] <- 0
x
# Let's check:
x <- c(1, 3, 8, 2, 20)
x[x > 3] <- 0
x
x <- c(6, 1:3, NA, 12)
x
x[x > 5] # NA included
subset(x, x > 5) # NA not included
z <- c(5, 2, -3, 8)
which(z * z > 8) # returns the elements of z which have squares greater than 8 (1,3,and 4)
x <- 1:10
y <- ifelse(x %% 2 == 0, 5, 12)
y # we are producing a vector in which there is a 5 wherever x is even or a 12 wherever x is odd
# another example:
x <- c(5, 2, 9, 12)
ifelse(x > 6, 2 * x, 3 * x)
# read data
data <- read.csv("http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data", header = FALSE)
names(data) <- c(
"sex", "length", "diameter", "height", "weight.whole",
"weight.shucked", "weight.viscera", "weight.shell", "rings"
)
data2 <- ifelse(data == "M", 1, ifelse(data == "F", 2, 3))
pchvec <- ifelse(data$gender == "M", "o", "x")
plot(data$length, data$diameter, pch = pchvec)
# If we want to test whether two vectors are equal, the naive approach using == won't work:
x <- 1:3
y <- c(1, 3, 4)
x == y
# we could work with the vectorized nature of == using the function all():
x <- 1:3
y <- c(1, 3, 4)
x == y
all(x == y)
identical(x,y)
# add names
x <- c(1, 2, 4)
names(x)
names(x) <- c("a", "b", "ab")
names(x)
x
# remove names
names(x) <- NULL
x
# reference elements of the vector by name:
x <- c(1, 2, 4)
names(x) <- c("a", "b", "ab")
x["b"]
# if the arguments you pass to c are of different modes, they will be reduced to a type that is the lowest common denominator
c(5, 2, "abc") # mixing integer and character modes, and R chooses the latter
c(5, 2, list(a = 1, b = 4)) # list mode here is of lower precedence
# c has a flattening effect for vectors:
c(5, 2, c(1.5, 6)) # this just results in a single vector, not a 2-level list
# list with tags
j <- list(name = "Joe", salary = 55000, union = T)
j
# list without tags
jalt <- list("Joe", 55000, T)
jalt
j$salary
j$salary
j[["salary"]]
j[[2]]
# double brackets
j$salary
j[["salary"]]
j[[2]]
# single brackets
j["salary"]
j[2]
j[1:2]
j2 <- j[2]
j2 # returns the result in the form of a list
class(j2)
j2a <- j[[2]]
j2a # works since we are only accessing a single element
class(j2a)
str(j2)
z <- list(a = "abc", b = 12)
z
# adding components
z$c <- "sailing"
z
# adding components via vector indexing
z[[4]] <- 28
z[5:7] <- c(FALSE, TRUE, TRUE)
z
# deleting elements
z$b <- NULL
z
# concatenating lists
c(list("Joe", 55000, T), list(5))
length(j)
# getting components tags
names(j)
# getting values
# character strings
ulj <- unlist(j)
class(ulj)
ulj
# numeric vector
z <- list(a = 5, b = 12, c = 13)
y <- unlist(z)
class(y)
y
# mixed = output -> the least common denominator: character strings
w <- list(a = 5, b = "xyz")
wu <- unlist(w)
class(wu)
wu
# removing names
names(wu) <- NULL
wu
# we can also remove the elements' names directly with unname:
wun <- unname(wu)
wun
lapply(list(1:3, 25:29), median)
sapply(list(1:3,25:29),median)
b <- list(u = 5, v = 12)
c <- list(w = 13)
a <- list(b, c)
a
length(a)
c(list(a = 1, b = 2, c = list(d = 5, e = 9)))
# flattening a list
c(list(a = 1, b = 2, c = list(d = 5, e = 9)), recursive = T)
kids <- c("Jack", "Jill")
ages <- c(12, 10)
d <- data.frame(kids, ages, stringsAsFactors = FALSE) # produce a data frame from our two vectors: kids and ages
d
# accessing data frames -> vector fashion
d[[1]]
d$kids
# matrix fashion
d[, 1]
str(d)
examsquiz <- read.table("input/ExamsQuiz.txt", header = TRUE)
examsquiz
# returns another data frame
examsquiz[2:5, ]
# returns a vector
examsquiz[2:5, 2]
class(examsquiz[2:5, 2])
# returns a one-column data frame
examsquiz[2:5, 2, drop = FALSE]
class(examsquiz[2:5, 2, drop = FALSE])
# filtering
examsquiz[examsquiz$MIDTERM >= 3.8, ]
x <- c(2, NA, 4)
mean(x)
mean(x, na.rm = TRUE)
# using subset() -> na.rm = TRUE per default
subset(examsquiz, MIDTERM >= 3.8)
# getting rid of any NA's observations
kids2 <- c("Jack", NA, "Jillian", "John")
states <- c("CA", "MA", "MA", NA)
d4 <- data.frame(kids2, states, stringsAsFactors = FALSE)
complete.cases(d4)
d5 <- d4[complete.cases(d4), ]
d5
kids3 <- c("Jack", "Jill")
ages <- c(12, 10)
d <- data.frame(kids3, ages, stringsAsFactors = FALSE)
d
# adding rows
d <- rbind(d, list("Laura", 19))
d
# creating new columns from old ones
eq <- cbind(examsquiz, examsquiz$FINAL - examsquiz$MIDTERM)
class(eq)
eq
# better solution
examsquiz$ExamDiff <- examsquiz$FINAL - examsquiz$MIDTERM
examsquiz
# adding cols with recycling
d$one <- 1
d
apply(examsquiz, 1, max)
kids.names <- c("Jack", "Jill", "Jillian", "John")
kids.states <- c("CA", "MA", "MA", "HI")
d1 <- data.frame(kids.names, kids.states, stringsAsFactors = FALSE)
kids.names <- c("Jill", "Lillian", "Jack")
kids.ages <- c(10, 7, 12)
d2 <- data.frame(kids.names, kids.ages, stringsAsFactors = FALSE)
d <- merge(d1, d2)
dl <- lapply(d2, sort)
dl
as.data.frame(dl)
# lintr::lint("main.Rmd", linters =
#               lintr::with_defaults(
#                 commented_code_linter = NULL,
#                 trailing_whitespace_linter = NULL
#                 )
#             )
# if you have additional scripts and want them to be linted too, add them here
# lintr::lint("scripts/my_script.R")
x <- c(5,12,13,12)
xf <- factor(x)
styler:::style_selection()
xf
str(xf)
unclass(xf)
length(xf)
# anticipating levels
xff <- factor(x,levels=c(5,12,13,88))
styler:::style_selection()
xff
xff[2] <- 88
xff
styler:::style_selection()
styler:::style_selection()
ages <- c(25, 26, 55, 37, 21, 42)
affils <- c("R", "D", "D", "R", "U", "D")
tapply(ages, affils, mean)
styler:::style_selection()
ages <- c(25, 26, 55, 37, 21, 42)
affils <- c("R", "D", "D", "R", "U", "D")
tapply(ages, affils, mean)
# with two or more factors
d <- data.frame(list(gender = c("M", "M", "F", "M", "F", "F"), age = c(47, 59, 21, 32, 33, 24), income = c(55000, 88000, 32450, 76500, 123000, 45650)))
d
styler:::style_selection()
d$over25 <- ifelse(d$age > 25, 1, 0)
d
styler:::style_selection()
tapply(d$income, list(d$gender, d$over25), mean)รง
tapply(d$income, list(d$gender, d$over25), mean)
ages <- c(25, 26, 55, 37, 21, 42)
affils <- c("R", "D", "D", "R", "U", "D")
tapply(ages, affils, mean)
# with two or more factors
d <- data.frame(list(gender = c("M", "M", "F", "M", "F", "F"), age = c(47, 59, 21, 32, 33, 24), income = c(55000, 88000, 32450, 76500, 123000, 45650)))
d
d$over25 <- ifelse(d$age > 25, 1, 0)
d
tapply(d$income, list(d$gender, d$over25), mean)
tapply(d$income, list(d$gender, d$over25), mean)
ages <- c(25, 26, 55, 37, 21, 42)
affils <- c("R", "D", "D", "R", "U", "D")
tapply(ages, affils, mean)
# with two or more factors
d <- data.frame(list(gender = c("M", "M", "F", "M", "F", "F"), age = c(47, 59, 21, 32, 33, 24), income = c(55000, 88000, 32450, 76500, 123000, 45650)))
d
d$over25 <- ifelse(d$age > 25, 1, 0)
d
tapply(d$income, list(d$gender, d$over25), mean)
styler:::style_selection()
split(d$income, list(d$gender, d$over25))
styler:::style_selection()
g <- c("M", "F", "F", "I", "M", "M", "F")
split(1:7, g)
View(data)
View(data)
View(data)
styler:::style_selection()
by(data, data$sex, function(m) lm(m[, 2] ~ m[, 3]))
styler:::style_selection()
u <- c(22, 8, 33, 6, 8, 29, -2)
fl <- list(c(5, 12, 13, 12, 13, 5, 13), c("a", "bc", "a", "a", "bc", "a", "a"))
tapply(u, fl, length)
table(fl)
ct <- read_tsv("input/ct.tsv")
ct
ct <- read_tsv("input/ct.tsv", header = T)
ct <- read.table("input/ct.tsv", header = T)
ct
cttab <- table(ct)
cttab <- table(ct)
cttab
styler:::style_selection()
# getting one-dimensional count
table(c(5, 12, 13, 12, 8, 5))
u <- c(22, 8, 33, 6, 8, 29, -2)
fl <- list(c(5, 12, 13, 12, 13, 5, 13), c("a", "bc", "a", "a", "bc", "a", "a"))
# creating a contingency table
tapply(u, fl, length)
# or (better!)
table(fl)
# getting one-dimensional count
table(c(5, 12, 13, 12, 8, 5))
# anothe contingency table example
ct <- read.table("input/ct.tsv", header = T)
ct
cttab <- table(ct)
cttab
class(cttab)
cttab[1,1]
styler:::style_selection()
styler:::style_selection()
cttab[1, ]
# change cell counts to proportions
cttab/5
# change cell counts to proportions
cttab/5 * 100
styler:::style_selection()
cttab / 5
# in pct
cttab / 5 * 100
apply(ctt,1,sum)
apply(cttab,1,sum)
styler:::style_selection()
addmargins(cttab)
class(cttab)
cttab[1, 1]
cttab[1, ]
# change cell counts to proportions
cttab / 5
# in pct
cttab / 5 * 100
# getting marginal totals
apply(cttab, 1, sum)
addmargins(cttab)
# getting names of the dimensions and levels
dimnames(cttab)
styler:::style_selection()
# extracting a subtable
subtable(cttab, list(Vote.for.X = c("No", "Yes"), Voted.for.X.Last.Time = c("No", "Yes")))
styler:::style_selection()
styler:::style_selection()
styler:::style_selection()
subtable <- function(tbl, subnames) {
tblarray <- unclass(tbl)
dcargs <- list(tblarray)
ndims <- length(subnames)
for (i in 1:ndims) {
dcargs[[i + 1]] <- subnames[[i]]
}
subarray <- do.call("[", dcargs)
dims <- lapply(subnames, length)
subtbl <- array(subarray, dims, dimnames = subnames)
class(subtbl) <- "table"
return(subtbl)
}
subtable(cttab, list(Vote.for.X = c("No", "Yes"), Voted.for.X.Last.Time = c("No", "Yes")))
styler:::style_selection()
styler:::style_selection()
styler:::style_selection()
tabdom <- function(tbl, k) {
tbldf <- as.data.frame(tbl)
freqord <- order(tbldf$Freq, decreasing = TRUE)
dom <- tbldf[freqord, ][1:k, ]
return(dom)
}
styler:::style_selection()
d <- c(5, 12, 13, 4, 3, 28, 12, 12, 9, 5, 5, 13, 5, 4, 12)
dtab <- table(d)
tabdom(dtab, 3)
tabdom(cttab,2)
styler:::style_selection()
aggregate(aba[,-1],list(aba$Gender),median)
styler:::style_selection()
aggregate(data[, -1], list(data$sex), median)
z <- c(0.88114802, 0.28532689, 0.58647376, 0.42851862, 0.46881514, 0.24226859, 0.05289197, 0.88035617)
seq(from=0.0,to=1.0,by=0.1)
styler:::style_selection()
binmarks <- seq(from = 0.0, to = 1.0, by = 0.1)
styler:::style_selection()
z <- c(0.88114802, 0.28532689, 0.58647376, 0.42851862, 0.46881514, 0.24226859, 0.05289197, 0.88035617)
binmarks <- seq(from = 0.0, to = 1.0, by = 0.1)
cut(z, binmarks, labels = F)
