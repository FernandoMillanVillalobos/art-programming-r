---
title: "The Art of R Programming"
subtitle: "A Tour of Statistical Software Design"
author: "Fernando Millan Villalobos"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    echo: TRUE
    warning: FALSE
    message: FALSE
    highlight: pygments
    theme: paper
    df_print: kable
    toc: yes
    toc_depth: 4
    number_sections: yes
    toc_float: 
      collapsed: yes
      smooth_scroll: false
---

```{r, include=FALSE}
## By default, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(
   echo=TRUE, message=FALSE, warning=FALSE
)
```

```{r, echo=FALSE}
# CONFIG
user_name <- "fernandomillanvillalobos" # your Git username (only needed if
# you want to deploy to GH pages)
project_name <- "art-programming-r" # adapt!
package_date <- "2022-05-01" # date of the CRAN snapshot that
# the checkpoint package uses
r_version <- "4.2.0" # R-Version to use
options(Ncpus = 4) # use 4 cores for parallelized installation of packages
if (r_version != paste0(version$major, ".", version$minor)) {
  stop("ERROR: specified R version does not match currently used.")
}
```

# Notes

This report was generated on `r Sys.time()`. R version: `r paste0(version$major, ".", version$minor)` on `r version$platform`. For this report, CRAN packages as of `r package_date` were used.

...

## R-Script & data

The preprocessing and analysis of the data was conducted in the [R project for statistical computing](https://www.r-project.org/). The RMarkdown script used to generate this document and all the resulting data can be downloaded [under this link](http://`r user_name`.github.io/`r project_name`/). Through executing `main.Rmd`, the herein described process can be reproduced and this document can be generated. In the course of this, data from the folder `input` will be processed and results will be written to `output`. The html on-line version of the analysis can be accessed through this [link](https://`r user_name`.github.io/`r project_name`/). 

## GitHub

The code for the herein described process can also be freely downloaded from [https://github.com/`r user_name`/`r project_name`](https://github.com/`r user_name`/`r project_name`). 

## License

...

## Data description of output files

#### `abc.csv` (Example)

| Attribute | Type | Description |
|-------|------|-----------------------------------------------------------------------------|
| a | Numeric | ... |
| b | Numeric | ... |
| c | Numeric |  ... |

...

# Set up

```{r, echo=FALSE}
detach_all_packages <- function() {
  basic_packages_blank <-  c("stats",
                             "graphics",
                             "grDevices",
                             "utils",
                             "datasets",
                             "methods",
                             "base")
  basic_packages <- paste("package:", basic_packages_blank, sep = "")

  package_list <- search()[
    ifelse(unlist(gregexpr("package:", search())) == 1, TRUE, FALSE)]

  package_list <- setdiff(package_list, basic_packages)

  if (length(package_list) > 0)  for (package in package_list) {
    detach(package, character.only = TRUE, unload = TRUE)
    print(paste("package ", package, " detached", sep = ""))
  }
}

detach_all_packages()

# this allows multiple persons to use the same RMarkdown
# without adjusting the working directory by themselves all the time
source("scripts/csf.R")
path_to_wd <- csf() # if this - for some reason - does not work,
# replace with a hardcoded path, like so: "~/projects/rddj-template/analysis/"
if (is.null(path_to_wd) | !dir.exists(path_to_wd)) {
  print("WARNING: No working directory specified for current user")
} else {
  setwd(path_to_wd)
}

# suppress scientific notation
options(scipen = 999)

# suppress summarise info
options(dplyr.summarise.inform = FALSE)

# unload global rstudioapi and knitr again to avoid conflicts with checkpoint
# this is only necessary if executed within RStudio
# outside of RStudio, namely in the knit.sh script, this causes RMarkdown
# rendering to fail, thus should not be executed there
if (Sys.getenv("RSTUDIO") == "1") {
  detach_all_packages()
}
```

## Define packages

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# from https://mran.revolutionanalytics.com/web/packages/\
# checkpoint/vignettes/using-checkpoint-with-knitr.html
# if you don't need a package, remove it from here (commenting not sufficient)
# tidyverse: see https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/
cat("
library(rstudioapi)
library(tidyverse)
library(tidylog)
library(jsonlite)
library(lintr)
library(rmarkdown)
library(rio)
library(cowplot)
library(extrafont)
library(ggrepel)
library(scales)
library(regtools)
library(openintro)
library(janitor)",
file = "manifest.R")
```

## Install packages

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# if checkpoint is not yet installed, install it (for people using this
# system for the first time)
if (!require(checkpoint)) {
  if (!require(devtools)) {
    install.packages("devtools", repos = "http://cran.us.r-project.org")
    require(devtools)
  }
  devtools::install_github("RevolutionAnalytics/checkpoint",
                           ref = "v0.3.2", # could be adapted later,
                           # as of now (beginning of July 2017
                           # this is the current release on CRAN)
                           repos = "http://cran.us.r-project.org")
  require(checkpoint)
}
# nolint start
if (!dir.exists("~/.checkpoint")) {
  dir.create("~/.checkpoint")
}
# nolint end
# install packages for the specified CRAN snapshot date
checkpoint(snapshot_date = package_date,
           project = path_to_wd,
           verbose = T,
           scanForPackages = T,
           use.knitr = F,
           R.version = r_version)
rm(package_date)
```

## Load packages

```{r, echo=TRUE, message=FALSE, warning=FALSE}
source("manifest.R")
unlink("manifest.R")
sessionInfo()
```

## Load additional scripts

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# if you want to outsource logic to other script files, see README for 
# further information
# Load all visualizations functions as separate scripts
knitr::read_chunk("scripts/dviz.supp.R")
source("scripts/dviz.supp.R")
knitr::read_chunk("scripts/themes.R")
source("scripts/themes.R")
knitr::read_chunk("scripts/plot_grid.R")
source("scripts/plot_grid.R")
knitr::read_chunk("scripts/align_legend.R")
source("scripts/align_legend.R")
knitr::read_chunk("scripts/label_log10.R")
source("scripts/label_log10.R")
knitr::read_chunk("scripts/outliers.R")
source("scripts/outliers.R")
```

# Use Base-R, Not the Tidyverse: An opinionated view of the Tidyverse "dialect" of the R language
Based on [Norm Matloff's](https://heather.cs.ucdavis.edu/matloff.html) article [Teaching R in a Kinder, Gentler, More Effective Manner:Use Base-R, Not the Tidyverse](https://github.com/matloff/TidyverseSkeptic).

```{r histogram}
# base-R
hist(Nile)

# Tidy
dn <- data.frame(Nile)
ggplot(dn) +
  geom_histogram(aes(Nile), dn)
```

```{r tapply}
mean(Nile[80:100])

# Case study: tapply()
# tapply(what to split, how to split it, what to apply to the resulting chunks)

# 1) base-R
aggregate(airquality[, "Ozone"],
  list(Month = airquality[, "Month"]),
  mean,
  na.rm = TRUE
)

# 2) base-R
aq <- na.omit(airquality)
tapply(aq$Ozone, aq$Month, mean)

# Tidy
group_by(airquality, Month) %>%
  summarize(o3 = mean(Ozone, na.rm = TRUE))
```

```{r linear-regression}
# Case study: tapply (II)
data("mlb", package = "regtools")
htsAndWts <- tapply(mlb$Weight, mlb$Height, mean)
plot(htsAndWts)

# Tidy
mlb %>%
  group_by(Height) %>%
  summarize(weights = mean(Weight)) %>%
  ggplot(aes(x = Height, y = weights)) +
  geom_point()          
```
```{r $and[]}
# avoiding $ use
# Tidy
loans_tidy <- openintro::loans_full_schema %>%
  mutate(
    homeownership = str_to_title(homeownership),
    bankruptcy = if_else(public_record_bankrupt >= 1, "Yes", "No")
  ) %>%
  filter(annual_income >= 10)
loans_tidy

# base-R
loans_base <- openintro::loans_full_schema
loans_base$bankruptcy <- ifelse(loans_base$public_record_bankrupt >= 1, "Yes", "No")
subset(loans_base, annual_income >= 10)
loans_base

# avoiding [] use
# base-R
x <- c(5, 12, 13, 1)
x[x > 8]
# or, if preferred:
subset(x, x > 8)

# Tidy
data.frame(x = x) %>% filter(x > 8)
```

```{r rigid-philosophy}
# base-R
mtcars$hwratio <- mtcars$hp / mtcars$wt
mtcars$hwratio

# Tidy
mtcars %>% mutate(hwratio = hp / wt) -> mtcars

# recoding variables
# base-R
mtcars$transmission <-
  ifelse(mtcars$am == 0, "automatic", "manual")

# Tidy
mtcars <- mtcars %>%
  mutate(
    transmission =
      case_when(
        am == 0 ~ "automatic",
        am == 1 ~ "manual"
      )
  )

# base-R
mtcars$gear_char <-
  ifelse(mtcars$gear == 3,
    "three",
    ifelse(mtcars$gear == 4,
      "four",
      "five"
    )
  )

# Tidy
mtcars <- mtcars %>%
  mutate(
    gear_char =
      case_when(
        gear == 3 ~ "three",
        gear == 4 ~ "four",
        gear == 5 ~ "five"
      )
  )

# combining base-R and Tidy
mtcars$gear_char <-
  case_when(
    mtcars$gear == 3 ~ "three",
    mtcars$gear == 4 ~ "four",
    mtcars$gear == 5 ~ "five"
  )
```

```{r tapply-2}
# Tidy v1
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(mean(mpg))

# Tidy v2 (no 8 cylinder, 4 speed cars)
mtcars$cyl <- as.factor(mtcars$cyl)
mtcars$gear <- as.factor(mtcars$gear)
mtcars %>%
  group_by(cyl, gear, .drop = FALSE) %>%
  summarize(mean(mpg))

# base-R
tapply(mtcars$mpg, list(mtcars$cyl, mtcars$gear), mean)
```

```{r map}
# regressing miles per gallon against weight, calculating R2 for each cylinder group
# Tidy
mtcars %>%
  split(.$cyl) %>%
  map(~ lm(mpg ~ wt, data = .)) %>%
  map(summary) %>%
  map_dbl("r.squared")

# base-R
# 1) creating a function
lmr2 <- function(mtcSubset) {
  lmout <- lm(mpg ~ wt, data = mtcSubset)
  summary(lmout)$r.squared
}

# 2) dividing cyl variable
u <- split(mtcars, mtcars$cyl)

# applying the function
sapply(u, lmr2)
```

# Vectors

## Scalars, Vectors, Arrays, and Matrices

The fundamental data type in R is the vector. In R, numbers are actually considered one-element vectors. R variable types are called modes. All elements in a vector must have the same mode, which can be integer, numeric (floating-point number), character (string), logical (Boolean), complex, and so on. If you need your program code to check the mode of a variable x, you can query it by the call `typeof(x)`. __Vector indices in R begin at 1__.

### Adding and Deleting Vector Elements
Vectors are stored contiguously, and thus you cannot insert or delete elements. The size of a vector is determined at its creation, so if you wish to add or delete elements, you’ll need to reassign the vector.

```{r}
x <- c(88, 5, 12, 13)
x <- c(x[1:3], 168, x[4]) #insert 168 before the 13
x
```
_x_ is really a pointer (like in JavaScript), and the reassignment is implemented by pointing _x_ to the newly created vector.

## Obtaining the Length of a Vector
You can obtain the length of a vector by using the `length()` function.

```{r}
x <- c(1,2,4)
length(x)
```
## Matrices and Arrays as Vectors

Arrays and matrices (and even lists, in a sense) are actually vectors too but they have extra class attributes. For example, matrices have the number of rows and columns.

```{r}
m <- rbind(c(1,2), c(3,4))
m
m + 10:13
```

## Declarations

As with most scripting languages you do not declare variables in R. However, __if you reference specific elements of a vector, you must warn R__. The reason we cannot suddenly spring an expression like y[2] on R stems from R’s functional language nature. The reading and writing of individual vector elements are actually handled by functions. If R doesn’t already know that y is a vector, these functions have nothing on which to act.

```{r}
y <- vector(length = 2)
y[1] <- 5
y[2] <- 12 # does work
y

y <- c(5, 12) # also works
y
```

## Recycling

When applying an operation to two vectors that requires them to be the same length, R automatically recycles, or repeats, the shorter one, until it is long enough to match the longer one.

```{r}
c(1, 2, 4) + c(6, 0, 9, 20, 22)

# gives the same result as:
c(1, 2, 4, 1, 2) + c(6, 0, 9, 20, 22)

#a more subtle example:
x <- cbind(c(1, 2, 3), c(4, 5, 6))
x
x + c(1, 2) # remember, matrices are actually long vectors! We are essentially doing this -> x + c(1,2,1,2,1,2)
```

## Common Vector Operations

### Vector Indexing

One of the most important and frequently used operations in R is that of indexing vectors, in which we form a subvector by picking elements of the given vector for specific indices. The format is vector1[vector2], with the result that we select those elements of vector1 whose indices are given in vector2. Negative subscripts mean that we want to exclude the given elements in our output.

```{r}
y <- c(1.2, 3.9, 0.4, 0.12)
y[c(1, 3)] # extract elements 1 and 3 of y
y[2:3] # elements 2 and 3

v <- 3:4 
y[v] # elements 3 and 4

x <- c(4, 2, 17, 5)
y <- x[c(1, 1, 3)] # duplicates are allowed 
y

# Negative subscripts are used to exclude given elements:
z <- c(5, 12, 13)
z[-1] # exclude element 1
z[-1:-2] # exclude elements 1 through 2

# pick up all elements of a vector except for the last
z <- c(5, 12, 13)
z[1:length(z) - 1]

# equivalently:
z[-length(z)]
```

### Generating Useful Vectors with the : Operator

There are a few R operators that are especially useful for creating vectors. the colon operator : produces a vector consisting of a range of numbers. 

```{r}
5:8
5:1

# Beware of operator precedence issues:
i <- 2
1:i - 1 # this means (1:i) - 1
# In the expression 1:i-1, the colon operator takes precedence over the subtraction. So, the expression 1:i is evaluated first, returning 1:2. R then subtracts 1 from that expression. That means subtracting a one-element vector from a two-element one, which is done via recycling. The one-element vector (1) will be extended to (1,1) to be of compatible length with 1:2. Element-wise subtraction then yields the vector (0,1).

1:(i - 1)
```

### Generating Vector Sequences with _seq()_

A generalization of : is the `seq()` (or sequence) function, which generates a sequence in arithmetic progression. One handy use for seq() is to deal with the empty-vector problem like in `for (i in 1:length(x))`. This can be replaced with `for (i in seq(x))`.

```{r}
seq(from = 12, to = 30, by = 3)
seq(1.1, 2, length = 10)

# Dealing with empty-vectors
x <- c(5,12,13)
x
seq(x) # vector is NOT empty 


x <- NULL
seq(x) # empty vector 
```
### Repeating Vector Constants with _rep()_

The `rep()` (or repeat) function allows us to conveniently put the same constant into long vectors. The call form is `rep(x,times)`, which creates a vector of times*length(x) elements—that is, times copies of x.

```{r}
x <- rep(8, 4)
x
rep(c(5, 12, 13), 3)
rep(1:3, 2)

# also a named argument, "each" which interleaves the copies of x
rep(c(5, 12, 13), each = 2)
```


## Using _all()_ and _any()_

They report whether any or all of their arguments are TRUE. The `any()` function then reports whether any of those values is TRUE. The `all()` function works similarly and reports if all of the values are TRUE.

```{r}
x <- 1:10
any(x > 8)
any(x > 88)
all(x > 8)
all(x > 0)

# Extended Example: Finding Runs of Consecutive Ones
# start with a function to do this:
findruns <- function(x, k) {
  n <- length(x)
  runs <- NULL
  for (i in 1:(n - k + 1)) {
    if (all(x[i:(i + k - 1)] == 1)) {
      runs <- c(runs, i)
    }
    return(runs)
  }
}

#let's test it:
y <- c(1, 0, 0, 1, 1, 1, 0, 1, 1)
findruns(y, 3)
findruns(y, 2)
findruns(y, 6)

#although the code is correct, it may be slow since each call to runs<-c(runs,i) allocates a new vector
#an alternative is to preallocate the memory space like this:
findruns1 <- function(x, k) {
  n <- length(x)
  runs <- vector(length = n)
  count <- 0
  for (i in 1:(n - k + 1)) {
    if (all(x[i:(i + k - 1)] == 1)) {
      count <- count + 1
      runs[count] <- i
    }
  }
  if (count > 0) {
    runs <- runs[1:count]
  } else {
    runs <- NULL
  }
  return(runs)
}

findruns1(y, 3)
findruns1(y, 2)
findruns1(y, 6)

# Extended Example: Predicting Discrete-Valued Time Series
# a naive approach:
preda <- function(x, k) {
  n <- length(x)
  k2 <- k / 2
  # the vector pred will contain our predicted values
  pred <- vector(length = n - k)
  for (i in 1:(n - k)) {
    if (sum(x[i:(i + (k - 1))]) >= k2) pred[i] <- 1 else pred[i] <- 0
  }
  return(mean(abs(pred - x[(k + 1):n])))
}

predb <- function(x, k) {
  n <- length(x)
  k2 <- k / 2
  pred <- vector(length = n - k)
  sm <- sum(x[1:k])
  if (sm >= k2) pred[1] <- 1 else pred[1] <- 0
  if (n - k >= 2) {
    for (i in 2:(n - k)) {
      sm <- sm + x[i + k - 1] - x[i - 1]
      if (sm >= k2) pred[i] <- 1 else pred[i] <- 0
    }
  }
  return(mean(abs(pred - x[(k + 1):n])))
}

predc <- function(x, k) {
  n <- length(x)
  k2 <- k / 2
  pred <- vector(length = n - k)
  csx <- c(o, cumsum(x))
  for (i in 1:(n - k)) {
    if (csx[i + k] - csx[i] >= k2) pred[i] <- 1 else pred[i] <- 0
  }
  return(mean(abs(pred - x[(k + 1):n])))
}
```

## Vectorized Operations

One of the most effective ways to achieve speed in R code is to use operations that are __vectorized, meaning that a function applied to a vector is actually applied individually to each element__. A key point is that __if an R function uses vectorized operations, it, too, is vectorized__. Even the transcendental functions—square roots, logs, trig functions, and so on—are vectorized. __Even operators such as + are really functions!__

### Vector In, Vector Out

```{r}
# some examples of vectorized functions
u <- c(5, 2, 8)
v <- c(1, 3, 9)
u > v

# example of an R function using vectorized operations
w <- function(x) {  
  return(x + 1)
}
w(u) # Here, w() uses +, which is vectorized, so w() is vectorized as well.

# built-in R vectorized functions
sqrt(1:9)
y <- c(1.2, 3.9, 0.4)
z <- round(y)
z

# even operators like + are really functions:
y <- c(12, 5, 13)
y + 4

"+"(y, 4) ## note too that recycling occurs here! 4 becomes (4,4,4).
```
### Vector In, Matrix Out

The vectorized functions we’ve been working with so far have scalar return values. Calling `sqrt()` on a number gives us a number. If we apply this function to an eight-element vector, we get eight numbers, thus another eight element vector, as output. But what if our function itself is vector-valued gives us the two-element vector. But we can streamline things using `sapply()` (or _simplify apply_). The call `sapply(x,f)` applies the function f() to each element of x and then converts the result to a matrix.

```{r}
# now let's consider vectorized functions that appear to have scalar arguments
f <- function(x, c) { # c is intended to be a scalar here
  return((x + c)^2)
} 

f(1:3, 0)
f(1:3, 1)

# a vector-valued function
z12 <- function(z) {
  return(c(z, z^2))
}

x <- 1:8
z12(x) # returns vector and values over these vectors together

# would be natural to represent these numbers as a matrix
matrix(z12(x), ncol = 2)

#the call sapply(x,f) applies the function f() to each element of x and then converts the result to a matrix
z12 <- function(z) {
  return(c(z, z^2))
}

sapply(1:8, z12)
```

## NA and NULL Values

R actually has two such values: NA and NULL. In statistical data sets, we often encounter __missing data__, which we represent in R with the value __NA__. __NULL__, on the other hand, represents that __the value in question simply doesn’t exist__, rather than being existent but unknown. One use of NULL is to build up vectors in loops, in which each iteration adds another element to the vector. NULL is a special R object with no mode.

```{r}
# Using NA
x <- c(88, NA, 12, 168, 13)
x
mean(x)
mean(x, na.rm = TRUE)  
# we have to specify if we want R to ignore the NA, but it will automatically ignore a NULL
x <- c(88, NULL, 12, 168, 13)
mean(x)

# there are multiple NA values, one for each mode:
x <- c(5, NA, 12)
mode(x[1])
mode(x[2])

y <- c("abc", "def", NA)
mode(y[2])
mode(y[3])

# Using NULL
# One use of NULL is to build up vectors in loops, in which each iteration adds another element to the vector
z <- NULL
for (i in 1:10) if (i %% 2 == 0) z <- c(z, i)
z
# in opposite to NAs
z <- NA
for (i in 1:10) if (i %% 2 == 0) z <- c(z, i)
z
```
## Filtering

Another feature reflecting the functional language nature of R is filtering. This allows us to extract a vector’s elements that satisfy certain conditions. Filtering is one of the most common operations in R, as statistical analyses often focus on data that satisfies conditions of interest.

### Generating Filtering Indices

```{r}
z <- c(5, 2, -3, 8)
z
z * z > 8 # we see that the operator >, like +, is actually a function
# for example:
">"(2, 1)
">"(2, 5)
# so the
z * z > 8
# is really equivalent to
">"(z * z, 8)
# in other words, we are applying a function to vectors, and thus the result is a vector (of Booleans)

# we define our extraction condition in terms of z, but then use the results to extract from another vector y
z <- c(5, 2, -3, 8)
j <- z * z > 8
j
y <- c(1, 2, 30, 5)
y[j]

# or, more compactly:
z <- c(5, 2, -3, 8)
y <- c(1, 2, 30, 5)
y[z * z > 8]

# another example: we have a vector x in which we wish to replace all elements larger than a 3 with a 0
x[x > 3] <- 0
x

# Let's check:
x <- c(1, 3, 8, 2, 20)
x[x > 3] <- 0
x
```
### Filtering with the _subset()_ Function

Filtering can also be done with the `subset()` function. When applied to vectors, the difference between using this function and ordinary filtering lies in the manner in which NA values are handled.

```{r}
x <- c(6, 1:3, NA, 12)
x
x[x > 5] # NA included
subset(x, x > 5) # NA not included
```
### The Selection Function _which()_

To find the positions within z at which the condition occurs. We can do this using `which()`.

```{r}
z <- c(5, 2, -3, 8)
which(z * z > 8) # returns the elements of z which have squares greater than 8 (1,3,and 4)
```
## A Vectorized if-then-else: The _ifelse()_ Function

In addition to the usual if-then-else construct found in most languages, R also includes a vectorized version, the `ifelse()` function. The advantage of ifelse() over the standard if-then-else construct is that it is vectorized, thus potentially much faster. The format is: `ifelse(b,u,v)` where b is a Boolean vector, and u and v are vectors. The return value is itself a vector; element i is u[i] if b[i] is true, or v[i] if b[i] is false. For each element of test that is true, the function evaluates to the corresponding element in yes. Similarly, if test[i] is false, the function evaluates to no[i]. All values so generated are returned together in a vector. __Due to the vector nature of the arguments, you can nest ifelse() operations.__ 

```{r}
x <- 1:10
y <- ifelse(x %% 2 == 0, 5, 12)
y # we are producing a vector in which there is a 5 wherever x is even or a 12 wherever x is odd

# another example:
x <- c(5, 2, 9, 12)
ifelse(x > 6, 2 * x, 3 * x)

# read data
data <- read.csv("http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data", header = FALSE)
names(data) <- c(
  "sex", "length", "diameter", "height", "weight.whole",
  "weight.shucked", "weight.viscera", "weight.shell", "rings"
)

data2 <- ifelse(data == "M", 1, ifelse(data == "F", 2, 3))

pchvec <- ifelse(data$gender == "M", "o", "x")
plot(data$length, data$diameter, pch = pchvec)
```

## Testing Vector Equality

Using `==` won’t work because we are dealing with vectorization. Just like almost anything else in R, `==` is a function. The expression x == y applies the function ==() to the elements of x and y. yielding a vector of Boolean values. We can work with the vectorized nature of `==`, applying the function `all()` or we can simply use the `identical()` function.

```{r}
# If we want to test whether two vectors are equal, the naive approach using == won't work:
x <- 1:3
y <- c(1, 3, 4)
x == y

# we could work with the vectorized nature of == using the function all():
x <- 1:3
y <- c(1, 3, 4)
x == y
all(x == y)

identical(x,y)
```
## Vector Element Names

The elements of a vector can optionally be given names via the `names()` function. We can even reference elements of the vector by name.

```{r}
# add names
x <- c(1, 2, 4)
names(x)
names(x) <- c("a", "b", "ab")
names(x)
x

# remove names
names(x) <- NULL
x

# reference elements of the vector by name:
x <- c(1, 2, 4)
names(x) <- c("a", "b", "ab")
x["b"]
```
## More on _c()_

If the arguments you pass to `c()` are of differing modes, they will be reduced to a type that is the lowest common denominator. `c()` has a flattening effect for vectors.

```{r}
# if the arguments you pass to c are of different modes, they will be reduced to a type that is the lowest common denominator
c(5, 2, "abc") # mixing integer and character modes, and R chooses the latter
c(5, 2, list(a = 1, b = 4)) # list mode here is of lower precedence

# c has a flattening effect for vectors:
c(5, 2, c(1.5, 6)) # this just results in a single vector, not a 2-level list
```

# Lists

## Creating Lists

Technically, a list is a vector. Ordinary vectors—those of the type we’ve been using so far in this book—are termed _atomic_ vectors, since their components cannot be broken down into smaller components. In contrast, lists are referred to as _recursive_ vectors. The component names—called _tags_ in the R literature—such as `salary` are optional. Names of list components can be abbreviated to whatever extent is possible without causing ambiguity.

```{r}
# list with tags
j <- list(name = "Joe", salary = 55000, union = T)
j
# list without tags
jalt <- list("Joe", 55000, T)
jalt

j$salary
```
## General List Operations

### List Indexing

You can access a list component in several different ways. We can refer to list components by their numerical indices, treating the list as a vector. So, there are three ways to access an individual component c of a list lst and _return it in the data type of c__. An alternative is to use single brackets rather than double brackets. Both single-bracket and double-bracket indexing access list elements in vector-index fashion. But there is an important difference from ordinary (atomic) vector indexing. If single brackets [ ] are used, the result is another list—a sublist of the original. The subsetting operation returned another list consisting of the x components of the original list j. Note that the word returned makes sense here, since __index brackets are functions__. By contrast, you can use double brackets [[ ]] for referencing only a single component, with the result having the type of that component.

```{r}
j$salary
j[["salary"]]
j[[2]]

# double brackets
j$salary
j[["salary"]]
j[[2]]

# single brackets
j["salary"] 
j[2]

j[1:2]
j2 <- j[2]
j2 # returns the result in the form of a list
class(j2)

j2a <- j[[2]]
j2a # works since we are only accessing a single element
class(j2a)
str(j2)
```

### Adding and Deleting List Elements

The operations of adding and deleting list elements arise in a surprising number of contexts. This is especially true for data structures in which lists form the foundation, such as data frames and R classes. __New components can be added__ after a list is created. Adding components can also be done via a vector index. You can __delete__ a list component by setting it to NULL. You can also __concatenate__ lists. Since a list is a vector, you can obtain the number of components in a list via `length()`.

```{r}
z <- list(a = "abc", b = 12)
z

# adding components
z$c <- "sailing"
z
# adding components via vector indexing
z[[4]] <- 28
z[5:7] <- c(FALSE, TRUE, TRUE)
z

# deleting elements
z$b <- NULL
z

# concatenating lists
c(list("Joe", 55000, T), list(5))

length(j)
```

## Accessing List Components and Values

If the components in a list do have tags, you can obtain them via `names()`. To obtain the values, use `unlist()`. The return value of unlist() is a vector. We can remove lksit names by setting their them to NULL or with with `unname()`.

```{r}
# getting components tags
names(j)

# getting values
# character strings
ulj <- unlist(j)
class(ulj)
ulj

# numeric vector
z <- list(a = 5, b = 12, c = 13)
y <- unlist(z)
class(y)
y

# mixed = output -> the least common denominator: character strings
w <- list(a = 5, b = "xyz")
wu <- unlist(w)
class(wu)
wu

# removing names
names(wu) <- NULL
wu

# we can also remove the elements' names directly with unname:
wun <- unname(wu)
wun
```

## Applying Functions to Lists

Two functions are handy for applying functions to lists: lapply and sapply.

### Using the _lapply()_ and _sapply()_ Functions

The function `lapply()` (for list apply) works calling the specified function on each component of a list (or vector coerced to a list) and returning another list. In some cases, such as the example here, the list returned by `lapply()` could be simplified to a vector or matrix. This is exactly what `sapply()` (for simplified [l]apply) does. The concatenate function `c()` has an optional argument recursive, which controls whether _flattening_ occurs when recursive lists are combined.

```{r}
lapply(list(1:3, 25:29), median)
sapply(list(1:3,25:29),median)
```

## Recursive Lists

Lists can be recursive, meaning that you can have lists within lists.

```{r}
b <- list(u = 5, v = 12)
c <- list(w = 13)
a <- list(b, c)
a
length(a)

c(list(a = 1, b = 2, c = list(d = 5, e = 9)))
# flattening a list
c(list(a = 1, b = 2, c = list(d = 5, e = 9)), recursive = T)
```

# Data Frames

On a technical level, a data frame is a list, with the components of that list being equal-length vectors. Actually, R does allow the components to be other types of objects, including other data frames. If the named argument stringsAsFactors is not specified, then by default, stringsAsFactors will be TRUE.

## Creating Data Frames

```{r}
kids <- c("Jack", "Jill")
ages <- c(12, 10)
d <- data.frame(kids, ages, stringsAsFactors = FALSE) # produce a data frame from our two vectors: kids and ages
d
```

### Accessing Data Frames

Since d is a list, we can access it as such via component index values or component names. But we can treat it in a matrix-like fashion as well. This matrix-like quality is also seen when we take d apart using `str()`. Consider three ways to access the first column of our data frame above: d[[1]], d[, 1], and d$kids, but matrix-like notation d[, 1] is especially handy if you are extracting subdata frames.

```{r}
# accessing data frames -> vector fashion
d[[1]]
d$kids

# matrix fashion
d[, 1]
str(d)

examsquiz <- read.table("input/ExamsQuiz.txt", header = TRUE)
examsquiz
```

## Other Matrix-Like Operations

### Extracting Subdata Frames

A data frame can be viewed in row-and-column terms. In particular, we can extract subdata frames by rows or columns. By specifying `drop=FALSE` we can keep them as a (one-column) data frame.    We can also do filtering.

```{r}
# returns another data frame
examsquiz[2:5, ]

# returns a vector
examsquiz[2:5, 2]
class(examsquiz[2:5, 2])

# returns a one-column data frame
examsquiz[2:5, 2, drop = FALSE]
class(examsquiz[2:5, 2, drop = FALSE])

# filtering
examsquiz[examsquiz$MIDTERM >= 3.8, ]
```
### More on Treatment of NA Values

In statistical analyses, R would do its best to cope with the missing data. However, in some situations, we need to set the option `na.rm=TRUE`, explicitly telling R to ignore NA values. The `subset()` function, which saves you the trouble of specifying `na.rm=TRUE`. You can apply it in data frames __for row selection__. The column names are taken in the context of the given data frame. In some cases, we may wish to rid our data frame of any observation that has at least one NA value. A handy function for this purpose is `complete.cases()`.

```{r}
x <- c(2, NA, 4)
mean(x)

mean(x, na.rm = TRUE)

# using subset() -> na.rm = TRUE per default
subset(examsquiz, MIDTERM >= 3.8)

# getting rid of any NA's observations
kids2 <- c("Jack", NA, "Jillian", "John")
states <- c("CA", "MA", "MA", NA)
d4 <- data.frame(kids2, states, stringsAsFactors = FALSE)
complete.cases(d4)
d5 <- d4[complete.cases(d4), ]
d5
```
### Using the _rbind()_ and _cbind()_ Functions and Alternatives

The `rbind()` and `cbind()` matrix functions work with data frames, too, providing that you have compatible sizes, of course. For instance, you can use `cbind()` to add a new column that has the same length as the existing columns. In using `rbind()` to add a row, the added row is typically in the form of another data frame or list. You can also create new columns from old ones. We can even exploit recycling to add a column that is of a different length than those in the data frame.

```{r}
kids3 <- c("Jack", "Jill")
ages <- c(12, 10)
d <- data.frame(kids3, ages, stringsAsFactors = FALSE)
d

# adding rows
d <- rbind(d, list("Laura", 19))
d

# creating new columns from old ones
eq <- cbind(examsquiz, examsquiz$FINAL - examsquiz$MIDTERM)
class(eq)
eq
# better solution
examsquiz$ExamDiff <- examsquiz$FINAL - examsquiz$MIDTERM
examsquiz

# adding cols with recycling
d$one <- 1
d
```

### Applying _apply()_

You can use `apply()` on data frames, if the columns are all of the same type.

```{r}
apply(examsquiz, 1, max)
```
## Merging Data Frames

In the relational database world, one of the most important operations is that of a join, in which two tables can be combined according to the values of a common variable. In R, two data frames can be similarly combined using the `merge()` function. The `merge()` function has named arguments `by.x` and `by.y`, which handle cases in which variables have similar information but different names in the two data frames, so you must choose matching variables with great care.

```{r}
kids.names <- c("Jack", "Jill", "Jillian", "John")
kids.states <- c("CA", "MA", "MA", "HI")
d1 <- data.frame(kids.names, kids.states, stringsAsFactors = FALSE)
kids.names <- c("Jill", "Lillian", "Jack")
kids.ages <- c(10, 7, 12)
d2 <- data.frame(kids.names, kids.ages, stringsAsFactors = FALSE)
d <- merge(d1, d2)
```

## Applying Functions to Data Frames

As with lists, you can use the `lapply` and `sapply` functions with data frames.

### Using _lapply()_ and _sapply()_ on Data Frames

Data frames are special cases of lists, with the list components consisting of the data frame’s columns. Thus, if you call `lapply()` on a data frame with a specified function `f()`, then `f()` will be called on each of the frame’s columns, with the return values placed in a list. We could coerce a list to a data frame with `as.data.frame()`.

```{r}
dl <- lapply(d2, sort)
dl
as.data.frame(dl)
```

# Factors and Tables

## Factors and Levels

An R factor might be viewed simply as a vector with a bit more information added. That extra information consists of a record of the distinct values in that vector, called _levels_. The core of _xf_ here is not (5,12,13,12) but rather (1,2,3,2). The latter means that our data consists first of a level-1 value, then level-2 and level-3 values, and finally another level-2 value. So the data has been recoded by level. The levels themselves are recorded too, of course, though as characters such as "5" rather than 5. The length of a factor is still defined in terms of the length of the data rather than being a count of the number of levels. We can anticipate future new levels.

```{r}
x <- c(5, 12, 13, 12)
xf <- factor(x)
xf
str(xf)
unclass(xf)
length(xf)

# anticipating levels
xff <- factor(x, levels = c(5, 12, 13, 88))
xff
xff[2] <- 88
xff
```

## Common Functions Used with Factors

With factors, we have yet another member of the family of apply functions, `tapply`, as well as two other functions commonly used with factors: `split()` and `by()`.

### The _tapply()_ Function

As motivation, suppose we have a vector x of ages of voters and a factor f showing some nonumeric trait of those voters, such as party affiliation (Democrat, Republican, Unaffiliated). We might wish to find the mean ages in x within each of the party groups. In typical usage, the call `tapply(x,f,g)` has x as a vector, f as a factor or list of factors, and g as a function. The function g() in our little example above would be R’s built-in mean() function. If we wanted to group by both party and another factor, say gender, we would need f to consist of the two factors, party and gender. Each factor in f must have the same length as x. If a component of f is a vector, it will be coerced into a factor by applying `as.factor()` to it. The operation performed by tapply() is to (temporarily) split x into groups, each group corresponding to a level of the factor (or a combination of levels of the factors in the case of multiple factors), and then apply g() to the resulting subvectors of x.

```{r}
ages <- c(25, 26, 55, 37, 21, 42)
affils <- c("R", "D", "D", "R", "U", "D")
tapply(ages, affils, mean)

# with two or more factors
d <- data.frame(list(gender = c("M", "M", "F", "M", "F", "F"), age = c(47, 59, 21, 32, 33, 24), income = c(55000, 88000, 32450, 76500, 123000, 45650)))
d
d$over25 <- ifelse(d$age > 25, 1, 0)
d
tapply(d$income, list(d$gender, d$over25), mean)
```
### The _split()_ Function

In contrast to `tapply()`, which splits a vector into groups and then applies a specified function on each group, `split()` stops at that first stage, just forming the groups. The basic form, without bells and whistles, is split(x,f), with x being a vector or data frame and f being a factor or a list of factors which are returned in a list. __x is allowed to be a data frame with split() but not with tapply()__.

```{r}
split(d$income, list(d$gender, d$over25))

# determine the indices of the vector elements corresponding to male, female, and infant
g <- c("M", "F", "F", "I", "M", "M", "F")
split(1:7, g)
```

### The _by()_ Function

Suppose in the abalone example we wish to do regression analyses of diameter against length separately for each gender code: males, females, and infants. At first, this seems like something tailor-made for `tapply()`, but the first argument of that function must be a vector, not a matrix or a data frame. Yet the input for regression is a matrix (or data frame) with at least two columns: one for the predicted variable and one or more for predictor variables. In our datalone data application, the matrix would consist of a column for the diameter data and a column for length. The `by()` function can be used here. It works like `tapply()` (which it calls internally, in fact), but it is applied to objects rather than vectors. Calls to `by()` look very similar to calls to `tapply()`, with the first argument specifying our data, the second the grouping factor, and the third the function to be applied to each group. Just as `tapply()` forms groups of indices of a vector according to levels of a factor, this `by()` call finds groups of row numbers of the data frame data That creates three subdata frames: one for each gender level of M, F, and I. The anonymous function we defined regresses the second column of its matrix argument m against the third column. This function will be called three times—once for each of the three subdata frames created earlier— thus producing the three regression analyses.

```{r}
by(data, data$sex, function(m) lm(m[, 2] ~ m[, 3]))
```
## Working with Tables

The `table()` function creates contingency tables correctly. The first argument in a call to `table()` is either a factor or a list of factors. The two factors here were (5,12,13,12,13,5,13) and ("a","bc","a","a","bc", "a","a"). Typically a data frame serves as the `table()` data argument. We can also get one-dimensional counts with `table()`, which are counts on a single factor 

```{r}
u <- c(22, 8, 33, 6, 8, 29, -2)
fl <- list(c(5, 12, 13, 12, 13, 5, 13), c("a", "bc", "a", "a", "bc", "a", "a"))

# creating a contingency table
tapply(u, fl, length)
# or (better!)
table(fl)

# getting one-dimensional count
table(c(5, 12, 13, 12, 8, 5))

# another contingency table example
ct <- read.table("input/ct.tsv", header = T)
ct
cttab <- table(ct)
cttab
```

### Matrix/Array-Like Operations on Tables

Just as most (nonmathematical) matrix/array operations can be used on data frames, they can be applied to tables, too. We can access the table cell counts using matrix notation. In statistics, the marginal values of a variable are those obtained when this variable is held constant while others are summed. We can of course obtain these via the matrix `apply()` function, but R supplies a function `addmargins()` for this purpose. We can get the names of the dimensions and levels through `dimnames()`. 

The function `subtable()` (deprecated) performs __subtable extraction__. It has two arguments:
- `tbl`: The table of interest, of class "table".
- `subnames`: A list specifying the desired subtable extraction. Each component of this list is named after some dimension of tbl, and the value of that component is a vector of the names of the desired levels.

It can be difficult to view a table that is very big, with a large number of rows or dimensions. One approach might be to focus on the cells with the largest frequencies. That’s the purpose of the `tabdom()` function developed below— __it reports the dominant frequencies in a table__.

```{r}
class(cttab)
cttab[1, 1]
cttab[1, ]

# change cell counts to proportions
cttab / 5
# in pct
cttab / 5 * 100

# getting marginal totals
apply(cttab, 1, sum)
addmargins(cttab)

# getting names of the dimensions and levels
dimnames(cttab)

# extracting a subtable
subtable <- function(tbl, subnames) {
  tblarray <- unclass(tbl)
  dcargs <- list(tblarray)
  ndims <- length(subnames)
  for (i in 1:ndims) {
    dcargs[[i + 1]] <- subnames[[i]]
  }
  subarray <- do.call("[", dcargs)
  dims <- lapply(subnames, length)
  subtbl <- array(subarray, dims, dimnames = subnames)
  class(subtbl) <- "table"
  return(subtbl)
}
subtable(cttab, list(Vote.for.X = c("No", "Yes"), Voted.for.X.Last.Time = c("No", "Yes")))

# focusing on the cells with the largest frequencies
# finds the cells in table tbl with the k highest frequencies; handling of ties is unrefined
tabdom <- function(tbl, k) {
  tbldf <- as.data.frame(tbl)
  freqord <- order(tbldf$Freq, decreasing = TRUE)
  dom <- tbldf[freqord, ][1:k, ]
  return(dom)
}

d <- c(5, 12, 13, 4, 3, 28, 12, 12, 9, 5, 5, 13, 5, 4, 12)
dtab <- table(d)
tabdom(dtab, 3)

tabdom(cttab, 2)
```

## Other Factor- and Table-Related Functions

R includes a number of other functions that are handy for working with tables and factors. We’ll discuss two of them here: `aggregate()` and `cut()`.

### The _aggregate()_ Function

The `aggregate()` function calls `tapply()` once for each variable in a group. The first argument, aba[,-1], is the entire data frame except for the first column, which is Gender itself. The second argument, which must be a list, is our Gender factor as before. Finally, the third argument tells R to compute the median on each column in each of the data frames generated by the subgrouping corresponding to our factors. There are three such subgroups in our example here and thus three rows in the output of `aggregate()`.

```{r}
aggregate(data[, -1], list(data$sex), median)
```

### The _cut()_ Function

A common way to generate factors, especially for tables, is the `cut()` function. You give it a data vector x and a set of bins defined by a vector b. The function then determines which bin each of the elements of x falls into. This returns a vector but we can convert it into a factor and possibly then use it to build a table.

```{r}
z <- c(0.88114802, 0.28532689, 0.58647376, 0.42851862, 0.46881514, 0.24226859, 0.05289197, 0.88035617)
binmarks <- seq(from = 0.0, to = 1.0, by = 0.1)
cut(z, binmarks, labels = F) # This says that z[1], 0.88114802, fell into bin 9, which was (0,0,0.1]; z[2], 0.28532689, fell into bin 3; and so on.
```

# R Programming Structures

Control statements in R look very similar to those of the ALGOL-descendant family languages: C, C++, Python, Perl and so on. 

## Control Statements

### Loops

The syntax for loops looks like this: `for (n in x) {` It means that there will be one iteration of the loop for each component of the vector x, with n taking on the values of those components—in the first iteration, n = x[1]; in the second iteration, n = x[2]; and so on. C-style looping with while and repeat is also available, complete with break, a statement that causes control to leave the loop. `repeat` has no Boolean exit condition. You must use `break` (or something like `return()`). Of course, `break` can be used with for loops, too.

Another useful statement is `next`, which instructs the interpreter to skip the remainder of the current iteration of the loop and proceed directly to the next one. This provides a way to avoid using complexly nested if-then-else constructs, which can make the code confusing. The `for` construct works on any vector, regardless of mode.

```{r}
# very simple loop
x <- c(5, 12, 13)
for (n in x) print(n^2)

# while and repeat
i <- 1
while(i <= 10) i <- i + 4;
i

# similar
i <- 1
while(TRUE){
  i <- i + 4
  if(i > 10) break
} 
i

# similar
i <- 1
repeat{
  i <- i + 4
  if(i > 10) break
} 
i

sim <- function(nreps) {
  commdata <- list()
  commdata$countabsamecomm <- 0
  for (rep in 1:nreps) {
    commdata$whosleft <- 1:20
    commdata$numabchosen <- 0
    commdata <- choosecomm(commdata, 5)
    if (commdata$numabchosen > 0) next
    commdata <- choosecomm(commdata, 4)
    if (commdata$numabchosen > 0) next
    commdata <- choosecomm(commdata, 3)
  }
  print(commdata$countabsamecomm / nreps)
}

# The two next statements occur within the loop that starts at line 1325. Thus, when the if condition holds in line 1329, lines 1330 through 1332 will be skipped, and control will transfer to line 1325. The situation in line 1331 is similar.

# without using next, we would need to resort to nested if statements
sim <- function(nreps) {
  commdata <- list()
  commdata$countabsamecomm <- 0
  for (rep in 1:nreps) {
    commdata$whosleft <- 1:20
    commdata$numabchosen <- 0
    commdata <- choosecomm(commdata, 5)
    if (commdata$numabchosen == 0) {
      commdata <- choosecomm(commdata, 4)
      if (commdata$numabchosen == 0) {
        commdata <- choosecomm(commdata, 3)
      }
    }
  }
  print(commdata$countabsamecomm / nreps)
} 

```

### Looping Over Nonvector Sets

__R does not directly support iteration over nonvector sets__, but there are a couple of indirect yet easy ways to accomplish it: 

- Use `lapply()`, assuming that the iterations of the loop are independent of each other, thus allowing them to be performed in any order. 
- Use `get()`. As its name implies, this function takes as an argument a character string representing the name of some object and returns the object of that name. It sounds simple, but `get()` is a very powerful function.

```{r}
# applying lm() to two matrices
u <- matrix(c(1, 2, 3, 1, 2, 4), nrow = 3, ncol = 2)
v <- matrix(c(8, 12, 20, 15, 10, 2), nrow = 3, ncol = 2)
for (m in c("u", "v")) {
  z <- get(m)
  print(lm(z[, 2] ~ z[, 1]))
}
```

### _if-else_

The syntax looks like this: `if (r == 4) { x <- 1 } else { x <- 3 y <- 4 }` The if section consists of just a single statement but the braces around that statement are necessary because the right brace before the else is used by the R parser to deduce that this is an if-else rather than just an if. An if-else statement works as a function call, and as such, it returns the last value assigned. When working with vectors, use the `ifelse()` function as it will likely produce faster code.

```{r}
x <- 2
y <- if (x == 2) x else x + 1
y

x <- 3
y <- if (x == 2) x else x + 1
y
```

## Arithmetic and Boolean Operators and Values

[Basic R Operators](img/basic-r-operators.png)

Though R ostensibly has no scalar types, with scalars being treated as one-element vectors, we see the exception in the above table: There are different Boolean operators for the scalar and vector cases. The central point is that in evaluating an if, we need a single Boolean, not a vector of Booleans as well as the need for having both the `&` and `&&` operators. The Boolean values TRUE and FALSE can be abbreviated as `T` and `F` (both must be capitalized).

# Linting

The code in this RMarkdown is linted with the [lintr package](https://github.com/jimhester/lintr), which is based on the  [tidyverse style guide](http://style.tidyverse.org/). 

```{r echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# lintr::lint("main.Rmd", linters =
#               lintr::with_defaults(
#                 commented_code_linter = NULL,
#                 trailing_whitespace_linter = NULL
#                 )
#             )
# if you have additional scripts and want them to be linted too, add them here
# lintr::lint("scripts/my_script.R")
```
