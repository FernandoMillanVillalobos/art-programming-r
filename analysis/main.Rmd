---
title: "The Art of R Programming"
subtitle: "A Tour of Statistical Software Design"
author: "Fernando Millan Villalobos"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    echo: TRUE
    warning: FALSE
    message: FALSE
    highlight: pygments
    theme: paper
    df_print: kable
    toc: yes
    toc_depth: 4
    number_sections: yes
    toc_float: 
      collapsed: yes
      smooth_scroll: false
---

```{r, include=FALSE}
## By default, show code for all chunks in the knitted document,
## as well as the output. To override for a particular chunk
## use echo = FALSE in its options.
knitr::opts_chunk$set(
   echo=TRUE, message=FALSE, warning=FALSE
)
```

```{r, echo=FALSE}
# CONFIG
user_name <- "fernandomillanvillalobos" # your Git username (only needed if
# you want to deploy to GH pages)
project_name <- "art-programming-r" # adapt!
package_date <- "2022-05-01" # date of the CRAN snapshot that
# the checkpoint package uses
r_version <- "4.2.0" # R-Version to use
options(Ncpus = 4) # use 4 cores for parallelized installation of packages
if (r_version != paste0(version$major, ".", version$minor)) {
  stop("ERROR: specified R version does not match currently used.")
}
```

# Notes

This report was generated on `r Sys.time()`. R version: `r paste0(version$major, ".", version$minor)` on `r version$platform`. For this report, CRAN packages as of `r package_date` were used.

...

## R-Script & data

The preprocessing and analysis of the data was conducted in the [R project for statistical computing](https://www.r-project.org/). The RMarkdown script used to generate this document and all the resulting data can be downloaded [under this link](http://`r user_name`.github.io/`r project_name`/). Through executing `main.Rmd`, the herein described process can be reproduced and this document can be generated. In the course of this, data from the folder `input` will be processed and results will be written to `output`. The html on-line version of the analysis can be accessed through this [link](https://`r user_name`.github.io/`r project_name`/). 

## GitHub

The code for the herein described process can also be freely downloaded from [https://github.com/`r user_name`/`r project_name`](https://github.com/`r user_name`/`r project_name`). 

## License

...

## Data description of output files

#### `abc.csv` (Example)

| Attribute | Type | Description |
|-------|------|-----------------------------------------------------------------------------|
| a | Numeric | ... |
| b | Numeric | ... |
| c | Numeric |  ... |

...

# Set up

```{r, echo=FALSE}
detach_all_packages <- function() {
  basic_packages_blank <-  c("stats",
                             "graphics",
                             "grDevices",
                             "utils",
                             "datasets",
                             "methods",
                             "base")
  basic_packages <- paste("package:", basic_packages_blank, sep = "")

  package_list <- search()[
    ifelse(unlist(gregexpr("package:", search())) == 1, TRUE, FALSE)]

  package_list <- setdiff(package_list, basic_packages)

  if (length(package_list) > 0)  for (package in package_list) {
    detach(package, character.only = TRUE, unload = TRUE)
    print(paste("package ", package, " detached", sep = ""))
  }
}

detach_all_packages()

# this allows multiple persons to use the same RMarkdown
# without adjusting the working directory by themselves all the time
source("scripts/csf.R")
path_to_wd <- csf() # if this - for some reason - does not work,
# replace with a hardcoded path, like so: "~/projects/rddj-template/analysis/"
if (is.null(path_to_wd) | !dir.exists(path_to_wd)) {
  print("WARNING: No working directory specified for current user")
} else {
  setwd(path_to_wd)
}

# suppress scientific notation
options(scipen = 999)

# suppress summarise info
options(dplyr.summarise.inform = FALSE)

# unload global rstudioapi and knitr again to avoid conflicts with checkpoint
# this is only necessary if executed within RStudio
# outside of RStudio, namely in the knit.sh script, this causes RMarkdown
# rendering to fail, thus should not be executed there
if (Sys.getenv("RSTUDIO") == "1") {
  detach_all_packages()
}
```

## Define packages

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# from https://mran.revolutionanalytics.com/web/packages/\
# checkpoint/vignettes/using-checkpoint-with-knitr.html
# if you don't need a package, remove it from here (commenting not sufficient)
# tidyverse: see https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/
cat("
library(rstudioapi)
library(tidyverse)
library(tidylog)
library(jsonlite)
library(lintr)
library(rmarkdown)
library(rio)
library(cowplot)
library(extrafont)
library(ggrepel)
library(scales)
library(regtools)
library(openintro)
library(janitor)",
file = "manifest.R")
```

## Install packages

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# if checkpoint is not yet installed, install it (for people using this
# system for the first time)
if (!require(checkpoint)) {
  if (!require(devtools)) {
    install.packages("devtools", repos = "http://cran.us.r-project.org")
    require(devtools)
  }
  devtools::install_github("RevolutionAnalytics/checkpoint",
                           ref = "v0.3.2", # could be adapted later,
                           # as of now (beginning of July 2017
                           # this is the current release on CRAN)
                           repos = "http://cran.us.r-project.org")
  require(checkpoint)
}
# nolint start
if (!dir.exists("~/.checkpoint")) {
  dir.create("~/.checkpoint")
}
# nolint end
# install packages for the specified CRAN snapshot date
checkpoint(snapshot_date = package_date,
           project = path_to_wd,
           verbose = T,
           scanForPackages = T,
           use.knitr = F,
           R.version = r_version)
rm(package_date)
```

## Load packages

```{r, echo=TRUE, message=FALSE, warning=FALSE}
source("manifest.R")
unlink("manifest.R")
sessionInfo()
```

## Load additional scripts

```{r, echo=TRUE, message=FALSE, warning=FALSE}
# if you want to outsource logic to other script files, see README for 
# further information
# Load all visualizations functions as separate scripts
knitr::read_chunk("scripts/dviz.supp.R")
source("scripts/dviz.supp.R")
knitr::read_chunk("scripts/themes.R")
source("scripts/themes.R")
knitr::read_chunk("scripts/plot_grid.R")
source("scripts/plot_grid.R")
knitr::read_chunk("scripts/align_legend.R")
source("scripts/align_legend.R")
knitr::read_chunk("scripts/label_log10.R")
source("scripts/label_log10.R")
knitr::read_chunk("scripts/outliers.R")
source("scripts/outliers.R")
```

# Use Base-R, Not the Tidyverse: An opinionated view of the Tidyverse "dialect" of the R language
Based on [Norm Matloff's](https://heather.cs.ucdavis.edu/matloff.html) article [Teaching R in a Kinder, Gentler, More Effective Manner:Use Base-R, Not the Tidyverse](https://github.com/matloff/TidyverseSkeptic).

```{r histogram}
# base-R
hist(Nile)

# Tidy
dn <- data.frame(Nile)
ggplot(dn) +
  geom_histogram(aes(Nile), dn)
```

```{r tapply}
mean(Nile[80:100])

# Case study: tapply()
# tapply(what to split, how to split it, what to apply to the resulting chunks)

# 1) base-R
aggregate(airquality[, "Ozone"],
  list(Month = airquality[, "Month"]),
  mean,
  na.rm = TRUE
)

# 2) base-R
aq <- na.omit(airquality)
tapply(aq$Ozone, aq$Month, mean)

# Tidy
group_by(airquality, Month) %>%
  summarize(o3 = mean(Ozone, na.rm = TRUE))
```

```{r linear-regression}
# Case study: tapply (II)
data("mlb", package = "regtools")
htsAndWts <- tapply(mlb$Weight, mlb$Height, mean)
plot(htsAndWts)

# Tidy
mlb %>%
  group_by(Height) %>%
  summarize(weights = mean(Weight)) %>%
  ggplot(aes(x = Height, y = weights)) +
  geom_point()          
```
```{r $and[]}
# avoiding $ use
# Tidy
loans_tidy <- openintro::loans_full_schema %>%
  mutate(
    homeownership = str_to_title(homeownership),
    bankruptcy = if_else(public_record_bankrupt >= 1, "Yes", "No")
  ) %>%
  filter(annual_income >= 10)
loans_tidy

# base-R
loans_base <- openintro::loans_full_schema
loans_base$bankruptcy <- ifelse(loans_base$public_record_bankrupt >= 1, "Yes", "No")
subset(loans_base, annual_income >= 10)
loans_base

# avoiding [] use
# base-R
x <- c(5, 12, 13, 1)
x[x > 8]
# or, if preferred:
subset(x, x > 8)

# Tidy
data.frame(x = x) %>% filter(x > 8)
```

```{r rigid-philosophy}
# base-R
mtcars$hwratio <- mtcars$hp / mtcars$wt
mtcars$hwratio

# Tidy
mtcars %>% mutate(hwratio = hp / wt) -> mtcars

# recoding variables
# base-R
mtcars$transmission <-
  ifelse(mtcars$am == 0, "automatic", "manual")

# Tidy
mtcars <- mtcars %>%
  mutate(
    transmission =
      case_when(
        am == 0 ~ "automatic",
        am == 1 ~ "manual"
      )
  )

# base-R
mtcars$gear_char <-
  ifelse(mtcars$gear == 3,
    "three",
    ifelse(mtcars$gear == 4,
      "four",
      "five"
    )
  )

# Tidy
mtcars <- mtcars %>%
  mutate(
    gear_char =
      case_when(
        gear == 3 ~ "three",
        gear == 4 ~ "four",
        gear == 5 ~ "five"
      )
  )

# combining base-R and Tidy
mtcars$gear_char <-
  case_when(
    mtcars$gear == 3 ~ "three",
    mtcars$gear == 4 ~ "four",
    mtcars$gear == 5 ~ "five"
  )
```

```{r tapply-2}
# Tidy v1
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(mean(mpg))

# Tidy v2 (no 8 cylinder, 4 speed cars)
mtcars$cyl <- as.factor(mtcars$cyl)
mtcars$gear <- as.factor(mtcars$gear)
mtcars %>%
  group_by(cyl, gear, .drop = FALSE) %>%
  summarize(mean(mpg))

# base-R
tapply(mtcars$mpg, list(mtcars$cyl, mtcars$gear), mean)
```

```{r map}
# regressing miles per gallon against weight, calculating R2 for each cylinder group
# Tidy
mtcars %>%
  split(.$cyl) %>%
  map(~ lm(mpg ~ wt, data = .)) %>%
  map(summary) %>%
  map_dbl("r.squared")

# base-R
# 1) creating a function
lmr2 <- function(mtcSubset) {
  lmout <- lm(mpg ~ wt, data = mtcSubset)
  summary(lmout)$r.squared
}

# 2) dividing cyl variable
u <- split(mtcars, mtcars$cyl)

# applying the function
sapply(u, lmr2)
```

# Vectors

## Scalars, Vectors, Arrays, and Matrices

The fundamental data type in R is the vector. In R, numbers are actually considered one-element vectors. R variable types are called modes. All elements in a vector must have the same mode, which can be integer, numeric (floating-point number), character (string), logical (Boolean), complex, and so on. If you need your program code to check the mode of a variable x, you can query it by the call `typeof(x)`. __Vector indices in R begin at 1__.

### Adding and Deleting Vector Elements
Vectors are stored contiguously, and thus you cannot insert or delete elements. The size of a vector is determined at its creation, so if you wish to add or delete elements, you’ll need to reassign the vector.

```{r}
x <- c(88, 5, 12, 13)
x <- c(x[1:3], 168, x[4]) #insert 168 before the 13
x
```
_x_ is really a pointer (like in JavaScript), and the reassignment is implemented by pointing _x_ to the newly created vector.

## Obtaining the Length of a Vector
You can obtain the length of a vector by using the `length()` function.

```{r}
x <- c(1,2,4)
length(x)
```
## Matrices and Arrays as Vectors

Arrays and matrices (and even lists, in a sense) are actually vectors too but they have extra class attributes. For example, matrices have the number of rows and columns.

```{r}
m <- rbind(c(1,2), c(3,4))
m
m + 10:13
```

## Declarations

As with most scripting languages you do not declare variables in R. However, __if you reference specific elements of a vector, you must warn R__. The reason we cannot suddenly spring an expression like y[2] on R stems from R’s functional language nature. The reading and writing of individual vector elements are actually handled by functions. If R doesn’t already know that y is a vector, these functions have nothing on which to act.

```{r}
y <- vector(length = 2)
y[1] <- 5
y[2] <- 12 # does work
y

y <- c(5, 12) # also works
y
```

## Recycling

When applying an operation to two vectors that requires them to be the same length, R automatically recycles, or repeats, the shorter one, until it is long enough to match the longer one.

```{r}
c(1, 2, 4) + c(6, 0, 9, 20, 22)

# gives the same result as:
c(1, 2, 4, 1, 2) + c(6, 0, 9, 20, 22)

#a more subtle example:
x <- cbind(c(1, 2, 3), c(4, 5, 6))
x
x + c(1, 2) # remember, matrices are actually long vectors! We are essentially doing this -> x + c(1,2,1,2,1,2)
```

## Common Vector Operations

### Vector Indexing

One of the most important and frequently used operations in R is that of indexing vectors, in which we form a subvector by picking elements of the given vector for specific indices. The format is vector1[vector2], with the result that we select those elements of vector1 whose indices are given in vector2. Negative subscripts mean that we want to exclude the given elements in our output.

```{r}
y <- c(1.2, 3.9, 0.4, 0.12)
y[c(1, 3)] # extract elements 1 and 3 of y
y[2:3] # elements 2 and 3

v <- 3:4 
y[v] # elements 3 and 4

x <- c(4, 2, 17, 5)
y <- x[c(1, 1, 3)] # duplicates are allowed 
y

# Negative subscripts are used to exclude given elements:
z <- c(5, 12, 13)
z[-1] # exclude element 1
z[-1:-2] # exclude elements 1 through 2

# pick up all elements of a vector except for the last
z <- c(5, 12, 13)
z[1:length(z) - 1]

# equivalently:
z[-length(z)]
```

### Generating Useful Vectors with the : Operator

There are a few R operators that are especially useful for creating vectors. the colon operator : produces a vector consisting of a range of numbers. 

```{r}
5:8
5:1

# Beware of operator precedence issues:
i <- 2
1:i - 1 # this means (1:i) - 1
# In the expression 1:i-1, the colon operator takes precedence over the subtraction. So, the expression 1:i is evaluated first, returning 1:2. R then subtracts 1 from that expression. That means subtracting a one-element vector from a two-element one, which is done via recycling. The one-element vector (1) will be extended to (1,1) to be of compatible length with 1:2. Element-wise subtraction then yields the vector (0,1).

1:(i - 1)
```

### Generating Vector Sequences with _seq()_

A generalization of : is the `seq()` (or sequence) function, which generates a sequence in arithmetic progression. One handy use for seq() is to deal with the empty-vector problem like in `for (i in 1:length(x))`. This can be replaced with `for (i in seq(x))`.

```{r}
seq(from = 12, to = 30, by = 3)
seq(1.1, 2, length = 10)

# Dealing with empty-vectors
x <- c(5,12,13)
x
seq(x) # vector is NOT empty 


x <- NULL
seq(x) # empty vector 
```
### Repeating Vector Constants with _rep()_

The `rep()` (or repeat) function allows us to conveniently put the same constant into long vectors. The call form is `rep(x,times)`, which creates a vector of times*length(x) elements—that is, times copies of x.

```{r}
x <- rep(8, 4)
x
rep(c(5, 12, 13), 3)
rep(1:3, 2)

# also a named argument, "each" which interleaves the copies of x
rep(c(5, 12, 13), each = 2)
```


## Using _all()_ and _any()_

They report whether any or all of their arguments are TRUE. The `any()` function then reports whether any of those values is TRUE. The `all()` function works similarly and reports if all of the values are TRUE.

```{r}
x <- 1:10
any(x > 8)
any(x > 88)
all(x > 8)
all(x > 0)

# Extended Example: Finding Runs of Consecutive Ones
# start with a function to do this:
findruns <- function(x, k) {
  n <- length(x)
  runs <- NULL
  for (i in 1:(n - k + 1)) {
    if (all(x[i:(i + k - 1)] == 1)) {
      runs <- c(runs, i)
    }
    return(runs)
  }
}

#let's test it:
y <- c(1, 0, 0, 1, 1, 1, 0, 1, 1)
findruns(y, 3)
findruns(y, 2)
findruns(y, 6)

#although the code is correct, it may be slow since each call to runs<-c(runs,i) allocates a new vector
#an alternative is to preallocate the memory space like this:
findruns1 <- function(x, k) {
  n <- length(x)
  runs <- vector(length = n)
  count <- 0
  for (i in 1:(n - k + 1)) {
    if (all(x[i:(i + k - 1)] == 1)) {
      count <- count + 1
      runs[count] <- i
    }
  }
  if (count > 0) {
    runs <- runs[1:count]
  } else {
    runs <- NULL
  }
  return(runs)
}

findruns1(y, 3)
findruns1(y, 2)
findruns1(y, 6)

# Extended Example: Predicting Discrete-Valued Time Series
# a naive approach:
preda <- function(x, k) {
  n <- length(x)
  k2 <- k / 2
  # the vector pred will contain our predicted values
  pred <- vector(length = n - k)
  for (i in 1:(n - k)) {
    if (sum(x[i:(i + (k - 1))]) >= k2) pred[i] <- 1 else pred[i] <- 0
  }
  return(mean(abs(pred - x[(k + 1):n])))
}

predb <- function(x, k) {
  n <- length(x)
  k2 <- k / 2
  pred <- vector(length = n - k)
  sm <- sum(x[1:k])
  if (sm >= k2) pred[1] <- 1 else pred[1] <- 0
  if (n - k >= 2) {
    for (i in 2:(n - k)) {
      sm <- sm + x[i + k - 1] - x[i - 1]
      if (sm >= k2) pred[i] <- 1 else pred[i] <- 0
    }
  }
  return(mean(abs(pred - x[(k + 1):n])))
}

predc <- function(x, k) {
  n <- length(x)
  k2 <- k / 2
  pred <- vector(length = n - k)
  csx <- c(o, cumsum(x))
  for (i in 1:(n - k)) {
    if (csx[i + k] - csx[i] >= k2) pred[i] <- 1 else pred[i] <- 0
  }
  return(mean(abs(pred - x[(k + 1):n])))
}
```

## Vectorized Operations

One of the most effective ways to achieve speed in R code is to use operations that are __vectorized, meaning that a function applied to a vector is actually applied individually to each element__. A key point is that __if an R function uses vectorized operations, it, too, is vectorized__. Even the transcendental functions—square roots, logs, trig functions, and so on—are vectorized. __Even operators such as + are really functions!__

### Vector In, Vector Out

```{r}
# some examples of vectorized functions
u <- c(5, 2, 8)
v <- c(1, 3, 9)
u > v

# example of an R function using vectorized operations
w <- function(x) {  
  return(x + 1)
}
w(u) # Here, w() uses +, which is vectorized, so w() is vectorized as well.

# built-in R vectorized functions
sqrt(1:9)
y <- c(1.2, 3.9, 0.4)
z <- round(y)
z

# even operators like + are really functions:
y <- c(12, 5, 13)
y + 4

"+"(y, 4) ## note too that recycling occurs here! 4 becomes (4,4,4).
```
### Vector In, Matrix Out

The vectorized functions we’ve been working with so far have scalar return values. Calling `sqrt()` on a number gives us a number. If we apply this function to an eight-element vector, we get eight numbers, thus another eight element vector, as output. But what if our function itself is vector-valued gives us the two-element vector. But we can streamline things using `sapply()` (or _simplify apply_). The call `sapply(x,f)` applies the function f() to each element of x and then converts the result to a matrix.

```{r}
# now let's consider vectorized functions that appear to have scalar arguments
f <- function(x, c) { # c is intended to be a scalar here
  return((x + c)^2)
} 

f(1:3, 0)
f(1:3, 1)

# a vector-valued function
z12 <- function(z) {
  return(c(z, z^2))
}

x <- 1:8
z12(x) # returns vector and values over these vectors together

# would be natural to represent these numbers as a matrix
matrix(z12(x), ncol = 2)

#the call sapply(x,f) applies the function f() to each element of x and then converts the result to a matrix
z12 <- function(z) {
  return(c(z, z^2))
}

sapply(1:8, z12)
```

## NA and NULL Values

R actually has two such values: NA and NULL. In statistical data sets, we often encounter __missing data__, which we represent in R with the value __NA__. __NULL__, on the other hand, represents that __the value in question simply doesn’t exist__, rather than being existent but unknown. One use of NULL is to build up vectors in loops, in which each iteration adds another element to the vector. NULL is a special R object with no mode.

```{r}
# Using NA
x <- c(88, NA, 12, 168, 13)
x
mean(x)
mean(x, na.rm = TRUE)  
# we have to specify if we want R to ignore the NA, but it will automatically ignore a NULL
x <- c(88, NULL, 12, 168, 13)
mean(x)

# there are multiple NA values, one for each mode:
x <- c(5, NA, 12)
mode(x[1])
mode(x[2])

y <- c("abc", "def", NA)
mode(y[2])
mode(y[3])

# Using NULL
# One use of NULL is to build up vectors in loops, in which each iteration adds another element to the vector
z <- NULL
for (i in 1:10) if (i %% 2 == 0) z <- c(z, i)
z
# in opposite to NAs
z <- NA
for (i in 1:10) if (i %% 2 == 0) z <- c(z, i)
z
```
## Filtering

Another feature reflecting the functional language nature of R is filtering. This allows us to extract a vector’s elements that satisfy certain conditions. Filtering is one of the most common operations in R, as statistical analyses often focus on data that satisfies conditions of interest.

### Generating Filtering Indices

```{r}
z <- c(5, 2, -3, 8)
z
z * z > 8 # we see that the operator >, like +, is actually a function
# for example:
">"(2, 1)
">"(2, 5)
# so the
z * z > 8
# is really equivalent to
">"(z * z, 8)
# in other words, we are applying a function to vectors, and thus the result is a vector (of Booleans)

# we define our extraction condition in terms of z, but then use the results to extract from another vector y
z <- c(5, 2, -3, 8)
j <- z * z > 8
j
y <- c(1, 2, 30, 5)
y[j]

# or, more compactly:
z <- c(5, 2, -3, 8)
y <- c(1, 2, 30, 5)
y[z * z > 8]

# another example: we have a vector x in which we wish to replace all elements larger than a 3 with a 0
x[x > 3] <- 0
x

# Let's check:
x <- c(1, 3, 8, 2, 20)
x[x > 3] <- 0
x
```
### Filtering with the _subset()_ Function

Filtering can also be done with the `subset()` function. When applied to vectors, the difference between using this function and ordinary filtering lies in the manner in which NA values are handled.

```{r}
x <- c(6, 1:3, NA, 12)
x
x[x > 5] # NA included
subset(x, x > 5) # NA not included
```
### The Selection Function _which()_

To find the positions within z at which the condition occurs. We can do this using `which()`.

```{r}
z <- c(5, 2, -3, 8)
which(z * z > 8) # returns the elements of z which have squares greater than 8 (1,3,and 4)
```
## A Vectorized if-then-else: The _ifelse()_ Function

In addition to the usual if-then-else construct found in most languages, R also includes a vectorized version, the `ifelse()` function. The advantage of ifelse() over the standard if-then-else construct is that it is vectorized, thus potentially much faster. The format is: `ifelse(b,u,v)` where b is a Boolean vector, and u and v are vectors. The return value is itself a vector; element i is u[i] if b[i] is true, or v[i] if b[i] is false. For each element of test that is true, the function evaluates to the corresponding element in yes. Similarly, if test[i] is false, the function evaluates to no[i]. All values so generated are returned together in a vector. __Due to the vector nature of the arguments, you can nest ifelse() operations.__ 

```{r}
x <- 1:10
y <- ifelse(x %% 2 == 0, 5, 12)
y # we are producing a vector in which there is a 5 wherever x is even or a 12 wherever x is odd

# another example:
x <- c(5, 2, 9, 12)
ifelse(x > 6, 2 * x, 3 * x)

# read data
data <- read.csv("http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data", header = FALSE)
names(data) <- c(
  "sex", "length", "diameter", "height", "weight.whole",
  "weight.shucked", "weight.viscera", "weight.shell", "rings"
)

data2 <- ifelse(data == "M", 1, ifelse(data == "F", 2, 3))

pchvec <- ifelse(data$gender == "M", "o", "x")
plot(data$length, data$diameter, pch = pchvec)
```

## Testing Vector Equality

Using `==` won’t work because we are dealing with vectorization. Just like almost anything else in R, `==` is a function. The expression x == y applies the function ==() to the elements of x and y. yielding a vector of Boolean values. We can work with the vectorized nature of `==`, applying the function `all()` or we can simply use the `identical()` function.

```{r}
# If we want to test whether two vectors are equal, the naive approach using == won't work:
x <- 1:3
y <- c(1, 3, 4)
x == y

# we could work with the vectorized nature of == using the function all():
x <- 1:3
y <- c(1, 3, 4)
x == y
all(x == y)

identical(x,y)
```
## Vector Element Names

The elements of a vector can optionally be given names via the `names()` function. We can even reference elements of the vector by name.

```{r}
# add names
x <- c(1, 2, 4)
names(x)
names(x) <- c("a", "b", "ab")
names(x)
x

# remove names
names(x) <- NULL
x

# reference elements of the vector by name:
x <- c(1, 2, 4)
names(x) <- c("a", "b", "ab")
x["b"]
```
## More on _c()_

If the arguments you pass to `c()` are of differing modes, they will be reduced to a type that is the lowest common denominator. `c()` has a flattening effect for vectors.

```{r}
# if the arguments you pass to c are of different modes, they will be reduced to a type that is the lowest common denominator
c(5, 2, "abc") # mixing integer and character modes, and R chooses the latter
c(5, 2, list(a = 1, b = 4)) # list mode here is of lower precedence

# c has a flattening effect for vectors:
c(5, 2, c(1.5, 6)) # this just results in a single vector, not a 2-level list
```

# Lists

## Creating Lists

Technically, a list is a vector. Ordinary vectors—those of the type we’ve been using so far in this book—are termed _atomic_ vectors, since their components cannot be broken down into smaller components. In contrast, lists are referred to as _recursive_ vectors. The component names—called _tags_ in the R literature—such as `salary` are optional. Names of list components can be abbreviated to whatever extent is possible without causing ambiguity.

```{r}
# list with tags
j <- list(name = "Joe", salary = 55000, union = T)
j
# list without tags
jalt <- list("Joe", 55000, T)
jalt

j$salary
```
## General List Operations

### List Indexing

You can access a list component in several different ways. We can refer to list components by their numerical indices, treating the list as a vector. So, there are three ways to access an individual component c of a list lst and _return it in the data type of c__. An alternative is to use single brackets rather than double brackets. Both single-bracket and double-bracket indexing access list elements in vector-index fashion. But there is an important difference from ordinary (atomic) vector indexing. If single brackets [ ] are used, the result is another list—a sublist of the original. The subsetting operation returned another list consisting of the x components of the original list j. Note that the word returned makes sense here, since __index brackets are functions__. By contrast, you can use double brackets [[ ]] for referencing only a single component, with the result having the type of that component.

```{r}
j$salary
j[["salary"]]
j[[2]]

# double brackets
j$salary
j[["salary"]]
j[[2]]

# single brackets
j["salary"] 
j[2]

j[1:2]
j2 <- j[2]
j2 # returns the result in the form of a list
class(j2)

j2a <- j[[2]]
j2a # works since we are only accessing a single element
class(j2a)
str(j2)
```

### Adding and Deleting List Elements

The operations of adding and deleting list elements arise in a surprising number of contexts. This is especially true for data structures in which lists form the foundation, such as data frames and R classes. __New components can be added__ after a list is created. Adding components can also be done via a vector index. You can __delete__ a list component by setting it to NULL. You can also __concatenate__ lists. Since a list is a vector, you can obtain the number of components in a list via `length()`.

```{r}
z <- list(a = "abc", b = 12)
z

# adding components
z$c <- "sailing"
z
# adding components via vector indexing
z[[4]] <- 28
z[5:7] <- c(FALSE, TRUE, TRUE)
z

# deleting elements
z$b <- NULL
z

# concatenating lists
c(list("Joe", 55000, T), list(5))

length(j)
```

## Accessing List Components and Values

If the components in a list do have tags, you can obtain them via `names()`. To obtain the values, use `unlist()`. The return value of unlist() is a vector. We can remove lksit names by setting their them to NULL or with with `unname()`.

```{r}
# getting components tags
names(j)

# getting values
# character strings
ulj <- unlist(j)
class(ulj)
ulj

# numeric vector
z <- list(a = 5, b = 12, c = 13)
y <- unlist(z)
class(y)
y

# mixed = output -> the least common denominator: character strings
w <- list(a = 5, b = "xyz")
wu <- unlist(w)
class(wu)
wu

# removing names
names(wu) <- NULL
wu

# we can also remove the elements' names directly with unname:
wun <- unname(wu)
wun
```

## Applying Functions to Lists

Two functions are handy for applying functions to lists: lapply and sapply.

### Using the _lapply()_ and _sapply()_ Functions

The function `lapply()` (for list apply) works calling the specified function on each component of a list (or vector coerced to a list) and returning another list. In some cases, such as the example here, the list returned by `lapply()` could be simplified to a vector or matrix. This is exactly what `sapply()` (for simplified [l]apply) does. The concatenate function `c()` has an optional argument recursive, which controls whether _flattening_ occurs when recursive lists are combined.

```{r}
lapply(list(1:3, 25:29), median)
sapply(list(1:3,25:29),median)
```

## Recursive Lists

Lists can be recursive, meaning that you can have lists within lists.

```{r}
b <- list(u = 5, v = 12)
c <- list(w = 13)
a <- list(b, c)
a
length(a)

c(list(a = 1, b = 2, c = list(d = 5, e = 9)))
# flattening a list
c(list(a = 1, b = 2, c = list(d = 5, e = 9)), recursive = T)
```

# Data Frames

On a technical level, a data frame is a list, with the components of that list being equal-length vectors. Actually, R does allow the components to be other types of objects, including other data frames. If the named argument stringsAsFactors is not specified, then by default, stringsAsFactors will be TRUE.

## Creating Data Frames

```{r}
kids <- c("Jack", "Jill")
ages <- c(12, 10)
d <- data.frame(kids, ages, stringsAsFactors = FALSE) # produce a data frame from our two vectors: kids and ages
d
```

### Accessing Data Frames

Since d is a list, we can access it as such via component index values or component names. But we can treat it in a matrix-like fashion as well. This matrix-like quality is also seen when we take d apart using `str()`. Consider three ways to access the first column of our data frame above: d[[1]], d[, 1], and d$kids, but matrix-like notation d[, 1] is especially handy if you are extracting subdata frames.

```{r}
# accessing data frames -> vector fashion
d[[1]]
d$kids

# matrix fashion
d[, 1]
str(d)
```

# Linting

The code in this RMarkdown is linted with the [lintr package](https://github.com/jimhester/lintr), which is based on the  [tidyverse style guide](http://style.tidyverse.org/). 

```{r echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# lintr::lint("main.Rmd", linters =
#               lintr::with_defaults(
#                 commented_code_linter = NULL,
#                 trailing_whitespace_linter = NULL
#                 )
#             )
# if you have additional scripts and want them to be linted too, add them here
# lintr::lint("scripts/my_script.R")
```
